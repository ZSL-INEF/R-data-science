[["index.html", "麻麻说我们可以用 R Markdown 写书了 前言 致谢", " 麻麻说我们可以用 R Markdown 写书了 张三 2022-11-17 前言 你好，世界。我写了一本书。这本书是这样的，第 ?? 章介绍了啥啥，第 ?? 章说了啥啥，然后是啥啥…… 我用了两个 R 包编译这本书，分别是 knitr (Xie 2015) 和 bookdown (Xie 2022)。以下是我的 R 进程信息： sessionInfo() ## R version 4.1.2 (2021-11-01) ## Platform: x86_64-apple-darwin17.0 (64-bit) ## Running under: macOS Catalina 10.15.7 ## ## Matrix products: default ## BLAS: /Library/Frameworks/R.framework/Versions/4.1/Resources/lib/libRblas.0.dylib ## LAPACK: /Library/Frameworks/R.framework/Versions/4.1/Resources/lib/libRlapack.dylib ## ## locale: ## [1] zh_CN.UTF-8/zh_CN.UTF-8/zh_CN.UTF-8/C/zh_CN.UTF-8/zh_CN.UTF-8 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets ## [6] methods base ## ## loaded via a namespace (and not attached): ## [1] bookdown_0.29 digest_0.6.30 R6_2.5.1 ## [4] jsonlite_1.8.0 magrittr_2.0.3 evaluate_0.18 ## [7] stringi_1.7.8 rlang_1.0.6 cli_3.4.1 ## [10] rstudioapi_0.13 jquerylib_0.1.4 bslib_0.3.1 ## [13] rmarkdown_2.14 tools_4.1.2 stringr_1.4.1 ## [16] xfun_0.34 yaml_2.3.6 fastmap_1.1.0 ## [19] compiler_4.1.2 htmltools_0.5.3 knitr_1.40 ## [22] sass_0.4.2 致谢 非常感谢谁谁以及谁谁对我的帮助。艾玛，要不是他们神一样的队友，我两年前就写完这本书了。 李震紐幣 References "],["r语言介绍.html", "第 1 章 R语言介绍 1.1 数据科学 1.2 R语言简介与Rstudio 1.3 Tidyverse简介 1.4 R语言包 1.5 R语言常用快捷键 1.6 数据分析与挖掘流程", " 第 1 章 R语言介绍 1.1 数据科学 1.1.1 数据科学的定义 数据科学是一门使用现代信息技术和工具来处理大量数据，从而发现数据中潜在的的模式并获取有意义的信息从而做出实际业务中的关键决策的研究领域。它基于传统的数学统计知识和现代快速发展的信息科技，使用复杂的机器学习算法针对相关领域的实际问题来建立相关模型并进行挖掘和分析，是一个高度综合、交叉的学科。也正是因为其高度的学科交叉特性，数据科学可以结合数理统计、数据分析、机器学习和专业知识等多方面信息，从已有的数据中挖掘出常规学科无法获取的知识。数据科学的生命周期包括捕获、维护、处理、分析和最终的交流，可以辅助决策者做出明智准确的商业判断。 1.1.2 数据科学与计算机科学、数理统计、机器学习等概念的区别 计算机科学是研究计算、自动化和信息的科学，其跨越理论学科(如算法、计算理论、信息论和自动化)到实践学科(包括硬件和软件的设计和实现)，核心问题是算法和数据结构。 数理统计学是应用数学的一个分支，涉及从定量数据中收集、描述、分析和推论结论，其背后的数学理论很大程度上依赖于微积分、线性代数和概率论。 专业知识又被称为经验、知识，是人类在实际生产活动中从实践中获得的经验和知识，他们往往是常规场景下进行判断和决策的重要依据。 学科的交叉融合可以产生新学科，机器学习和数据科学等就由此而来。基于已有的知识和经验，使用统计学手段研究实际问题是传统分析；利用计算机科学和专业知识解决问题的过程被称为软件开发；计算机科学与数理统计相结合则产生了机器学习。而数据科学，则是融合数理统计、计算机科学和专业知识等为一体的高度交叉学科。 1.1.3 数据科学的重要价值 随着科技的不断进步，现代技术能够产生和存储越来越多的信息，数据量呈现爆炸式增长，许多公司都因此拥有极为丰富的数据宝库。据估计，目前世界上90%的数据都是在过去两年内产生的，比如Facebook用户每小时可以上传高达1000万张图片，微信每天有多达450亿次消息发送，有约4.1亿次音视频呼叫成功。但遗憾的是，公司所产生的绝大部分数据都往往只是存放在数据仓库中，无法得到有效利用。 事实上，通过已有技术收集和存储的大量数据可以为世界各地的组织和社会带来变革性的好处-但前提是我们能够处理和解释这些数据，这就是数据科学的用武之地。数据科学可以用于揭示数据中蕴含的趋势和规律，进而辅助企业决策层做出更好的决策，创造更多创新的产品和服务。更加重要的是，数据科学可以利用机器学习模型从海量的数据输入中不断学习新的知识，这相比传统的业务模式-主要依赖于业务分析人员从少量数据中得到新发现新知识，有巨大的优势。因此，数据是创新的基石，但它的价值来自其中蕴含的信息和规律，而这个过程离不开数据科学。 1.1.4 数据科学的生命周期 数据科学的生命周期主要分为五个独立的阶段，每一阶段都有其特定的任务。 捕获：捕获阶段主要集中在收集结构化和非结构化的数据，包括数据采集、数据输入、信号接收和数据提取等。 维护：维护阶段主要是获取原始数据，并进行一定程度的预处理，然后将数据以方便实用的形式妥善保存在安全的介质中。包括建立和维护数据仓库、数据清洗、数据分级、数据预处理、设计数据架构等。 处理：处理阶段主要是数据科学家基于准备好的数据，检查数据模态、范围和偏差来决定数据在实际应用中的有效性。包括数据建模和数据汇总等。 分析：分析是数据科学中的主要阶段之一，涉及到对数据的探索性或验证性分析，进行数据分析和数据挖掘。包括预测分析、回归分析、文本挖掘等。 交流：交流是数据科学生命周期的最后一阶段，分析人员以易于理解和阅读的方式（如图表和报告等）汇报和讲解分析结果。包括数据可视化、商务决策等。 1.2 R语言简介与Rstudio R语言是用于统计计算和绘图的免费软件。它可以在Windows, Unix以及MacOS等系统下运行。用户可以从网上免费下载R语言。 R是由Ross Ihaka和Robert Gentleman在1993年开发的一种编程语言，现在由R开发核心团队负责开发。R语言的起源可以追溯到80年代，那时候的AT&amp;T贝尔实验室（也就是现在的朗讯科技）开发了S语言进行数据挖掘、统计分析和绘图。S语言后来演变成为了商业软件S-Plus。后来有一些志愿者将S-Plus改进成为免费的R语言。R语言的统计功能强大，包括线性和非线性模型，经典统计检验、时间序列分析、聚类分析等等，并且具有高度的可扩展性。 R语言是一个自由、免费、开源的软件。在自由软件基金会的GNU通用公共许可证的条款下，R是以源代码形式提供的自由软件。它可以在各种UNIX平台和类似系统（包括FreeBSD和Linux）、Windows和MacOS上编译和运行。另外，R语言的编程简单易学。你可以自己写函数，将最新的统计方法应用到R语言中去。R语言的函数和数据集都保存在程序包里面。当我们需要访问这些函数和数据时，需要下载相关的程序包。 除此之外，R还具有顶尖的绘图功能。尤其对于复杂数据的可视化问题，R的优势更加明显。一方面，R中各种绘图函数和绘图参数的综合使用，可以得到各式各样的图形结果，无论对于常用的直方图、饼图、条形图等，还是复杂的组合图、地图、热图、动画，以及自己脑子里突然想到的其他图形展现方式，都可以采用R语言实现。另一方面，从数值计算到得到图形结果的过程灵活，一旦程序写好后，如果需要修改数据或者调整图形，只需要修改几个参数或者直接替换原始数据即可，不用重复劳动。这对需要绘制大量同类图形的用户比较适用。例如，某用户需要观察某一因素与其他100个因素的交互关系，可以绘制100个条形图或走势图。配合R的循环和条形图功能，可以很快得到jpg、png、bmp、tiff、gif或postscript等格式的图形结果。 RStudio是R语言的集成开发环境(IDE)，它是一个独立的开源项目，它将许多功能强大的编程工具集成到一个直观、易于学习的界面中，包括控制台、语法高亮编辑器，支持直接执行代码，以及绘图、历史、调试和工作区管理的工具。 IDE的主要组件都很好地集成到一个四面板布局中，其中包括用于交互式R会话的控制台、用于组织项目文件的带选项卡的源代码编辑器，以及用于组织较少中心组件的带笔记本的面板。 源代码编辑器功能丰富，并与内置控制台集成。 通过选项卡完成和帮助页面查看器组件，控制台和源代码编辑器与R的内部帮助系统紧密相连。 设置不同的项目很容易，在它们之间进行切换甚至更容易。 RStudio提供了许多方便且易于使用的管理工具，用于管理包、工作区、文件等。 IDE可用于三种主要操作系统，可以通过web浏览器进行远程访问。 RStudio比Emacs/ESS更容易学习，比Emacs/ESS更容易配置和安装 Eclipse/StatET拥有比JGR更好的编辑器，比JGR更有组织性 Sciviews不同于notepad++和RGui，它可以在更多的平台上使用，而不只是windows。 RStudio可以在所有主要平台(Windows、Mac、Linux)上运行，也可以通过web浏览器(使用服务器安装，连接到RStudio Server或RStudio Workbench（Debian/Ubuntu、Red Hat/CentOS和SUSE Linux）的浏览器中)运行。 1.3 Tidyverse简介 Tidyverse是R语言的一个程序包，是由伟大的Hadley Wickham和他的团队创建的，目的是提供所有这些工具来清理和处理数据。Tidy的意思是干净、整洁。Verse的意思是诗歌、歌曲。那么Tidyverse的意思就是干净整洁的语句。 Tidyverse可以大大简化数据处理和分析，它有八个核心软件包，分别是ggplot2、dplyr、tidyr、readr、purrr、tibble、stringr和forcats。所有这些包都是通过install.packages(“tidyverse”)命令一次性自动加载的。除了这些包之外，Tidyverse还有一些特殊的包，它们不是自动加载的，而是需要自己调用的。这些包括用于关系数据库的DBI。用于网络API的httr，用于网络刮削的rvest，等等。 1.3.1 数据可视化和探索 1.3.1.1 ggplot2 ggplot2是一个基于The Grammar of Graphics的R数据可视化库。ggplot2可以使用高级API创建数据可视化，如柱状图、饼图、柱状图、散点图、误差图等。它还允许你在单个可视化中添加不同类型的数据可视化组件或层。一旦ggplot2被告知哪些变量要映射到图中的哪些美学，它就会完成剩下的工作，这样用户就可以专注于解释可视化，而在创建可视化时花费更少的时间。但这也意味着不可能在ggplot2中创建高度定制的图形。但在RStudio社区和Stack Overflow中有很多资源，可以在需要时提供ggplot2的帮助。 1.3.2 数据处理和转换 1.3.2.1 dplyr dplyr是R语言中一个非常流行的数据处理库，它有五个重要的函数，与group_by()函数自然结合，可以帮助分组执行这些函数。这些函数包括mutate()函数，它可以添加新的变量，这些变量是现有变量的函数，select()函数根据变量的名称选择变量，filter()函数根据变量的值选择变量，summaryise()函数将多个值缩减为一个摘要，arrange()函数安排排列行的顺序。 1.3.2.2 tidyr tidyr是R语言中的一个数据清理库，它有助于创建整洁的数据。整齐的数据意味着所有的数据单元都有一个单一的值，每一列数据都是一个变量，每一行数据都是一个观察值。这种整洁的数据是tidyverse的主要内容，它确保了更多的时间花在数据分析和从数据中获取价值上，而不是不断地清洗数据和修改工具来处理不整洁的数据。tidyr中的功能大致分为五类，即：透视，在长形和宽形之间改变数据；嵌套，改变分组数据，使一个组成为具有嵌套数据框架的单行；拆分字符列，然后合并它们。将嵌套的列表转换为整齐的二维码，并将隐式缺失值转换为显式值。 1.3.2.3 stringr stringr是一个库，有许多用于数据清理和数据准备任务的功能。它也是为处理字符串而设计的，并且有许多函数使这一过程变得简单。stringr是建立在stringi之上的，而stringi是International Components for Unicode C库。因此，如果有任何你想使用但在stringr中找不到的函数，那么最好的地方就是stringi。这也意味着，一旦你掌握了stringr，stringi的使用就不那么困难了，因为这两个包都有类似的约定。stringr中的所有函数都以str开头，它们接受一个字符串向量作为其第一个参数。其中一些函数包括str_detect(), str_extract(), str_match(), str_count(), str_replace(), str_subset()，等等。 1.3.2.4 forcats forcats是一个R库，主要是处理与向量有关的问题。这些向量是有一组固定的可能取值的变量，这些值是事先知道的。所以forecats处理的问题包括改变向量中的值的顺序，重新排序向量等。forcats中的一些函数是fct_relevel()，它通过手工对向量进行排序，fct_reorder()使用另一个变量对一个因子进行排序，fct_infreq()通过频率值对一个因子进行排序等等。 1.3.3 数据导入和管理 1.3.3.1 tibble tibble是data.frame的一种形式，它包括了其中有用的部分，而抛弃了不太重要的部分。所以tibbles不会像data.frame那样改变变量的名称或类型，也不会做部分匹配，但它们能更快地将问题暴露出来，例如当一个变量不存在时。因此，使用Tibbles的代码要比以前干净和有效得多。Tibbles也更容易用于包含更复杂对象的更大的数据集，部分原因是增强了print()方法。你可以使用tibble()函数从列向量创建新的tibbles，你也可以使用tribble()函数逐行创建一个tibble。 1.3.3.2 readr 这个库提供了一个简单而快速的方法来读取矩形数据，如文件格式tsv, csv, delim, fwf等。readr可以使用一个解析整个文件的函数和另一个专注于特定列的函数来解析许多不同类型的数据。这个列规范定义了将该列中的数据从字符向量转换为最适合的数据类型的方法。在大多数情况下，这是 readr 自动完成的。 readr 可以使用不同的函数读取不同类型的文件格式，即 read_csv() 用于逗号分隔的文件，read_tsv() 用于标签分隔的文件，read_table() 用于表格文件，read_fwf() 用于固定宽度的文件，read_delim() 用于分隔文件，以及，read_log() 用于网页日志文件。 1.3.4 功能性编程 1.3.4.1 purrr Purrr是一套详细的函数和向量工具，它主要用于管理R语言中的函数式编程。一个很好的例子是map()函数，它被用来取代多个for循环，这些for循环使代码变得复杂和混乱，从而使代码更简单，易于阅读。除此之外，所有的purrr函数都是类型稳定的，这意味着它们要么返回宣传的输出类型，如果不可能，则会给出一个错误。 1.4 R语言包 R包是由社区开发的函数和数据集的集合。它们通过改进现有的基本R功能或增加新的功能来提高R的能力。例如，如果你经常处理数据框架，你可能听说过dplyr或data.table这两个最流行的R包。 R的基本安装包含了许多有用的标准包。这些包将包含许多你每天都会用到的功能。然而，当你开始在更多的项目中使用R时（以及你自己对R的使用也在不断发展），你会发现有一天你需要扩展R的功能。 令人高兴的是，成千上万的R用户已经开发出了有用的代码，并以可安装包的形式分享这些代码。你可以把包看作是一个函数、数据和帮助文件的集合，它被整理成一个定义良好的标准结构，你可以在R中下载和安装。这些包可以从各种来源下载，但最流行的是CRAN、Bioconductor和GitHub。目前，CRAN承载了超过15000个软件包，是用户贡献的R软件包的官方存储库。 Bioconductor提供了面向生物信息学的开源软件，托管了1800多个R包。GitHub是一个为各种软件和项目（不仅仅是R）托管git仓库的网站。通常，R包的尖端开发版本都托管在GitHub上，所以如果你需要所有的新功能，那么这可能是一个选择。然而，使用R包的开发版本的一个潜在缺点是，它可能不像CRAN上的版本那样稳定（它正在开发中！），而且更新包不会自动进行。 1.5 R语言常用快捷键 显示所有快捷键 ：如果想看所有快捷键，可按alt + shift + k；或者在界面中点击Tools + Keyboard Shortcuts Help。 快速运行： ctrl + alt + R 运行该脚本所有代码 ctrl + Enter 运行当前鼠标所在行代码 新建脚本：Ctrl+Shift+N 快速新建脚本 多行注释：先选中所要注释的代码，然后按ctrl + shift + c。如果想取消注销，再选中代码，再后ctrl + shift + c 代码折叠与展开：有时候在函数的时候，或者Rmarkdown写代码行时，发现内容很多想把它折叠起来，这时候就可以用这个快捷键。 alt + o 折叠所有文件夹 alt + shift + o 展开所有文件夹 alt + L 折叠当前文件夹 alt + shift + L 展开当前文件夹 注意：这里的o不是指数字0。 管道函数：ctrl + shift + M 赋值 ：&lt;- 怎么打？快捷键：alt + - 帮助help：如果遇到函数搞不懂这个函数什么意思，将光标放到函数中间，然后按F1键即可查看函数细节，或者?函数。 复制并粘贴代码：shift+Ctrl+D 在一行代码末尾或者选中一堆代码后使用更佳 设置工作路径：按快捷键ctrl + shift + H之后显示当前目录，你可以选择其他路径作为当前目录。或者可以通过窗口操作，点击Sessin中的Set Working Directory 搜索历史记录：假如想找以前提交的命令怎么办？在控制台中，通过 Ctr + [向上箭头]可以搜索到历史记录。或者通过窗口操作，右上角有个History，点击即可 创建可折叠注释：Ctrl + Shift + R 重启RStudio中的R：ctrl + shift + F10 运行代码卡住时可以使用 函数提取：如果你已经写了一段代码，你想把它转换成一个函数，则可以输入Ctrl + Alt + X，这时会出现一个弹出窗口，要求你输出一个函数名 控制台Console Description Windows &amp;Linux Mac 将光标定位到控制台 Ctrl+2 Command+2 清空控制台 Ctrl+L Command+L 将光标定位到行首 Home Command+Left 将光标定位到行末 End Command+Right 在历史命令中导航 Up/Down Up/Down 弹出历史命令框 Ctrl+Up Command+Up 中断当前命令的执行 Esc Esc 改变工作目录 Ctrl+Shift+K Ctrl+Shift+K Source Description Windows &amp; Linux Mac 跳转到文件/函数 Ctrl+. Ctrl+. 光标定位到源码编辑器 Ctrl+1 Ctrl+1 新建一个文件 Ctrl+Shift+N Command+Shift+N 打开文件 Ctrl+O Command+O 保存当前文件 Ctrl+S Command+S 关闭当前文件 Ctrl+W Command+W 关闭当前文件(仅适用于Chrome) Ctrl+Shift+Z Command+Shift+Z 关闭所有打开的文件 Ctrl+Shift+W Command+Shift+W 在HTML里面预览 Ctrl+Shift+Y Command+Shift+Y Knit to HTML Ctrl+Shift+H Command+Shift+H 编译PDF (TeX and Sweave) Ctrl+Shift+I Command+Shift+I 插入块 Ctrl+Alt+I Command+Option+I 插入代码段 Ctrl+Shift+R Command+Shift+R 运行当前/被选中的代码 Ctrl+Enter Command+Enter 再次运行以前区域 Ctrl+Shift+P Command+Shift+P 运行当前文件 Ctrl+Alt+R Command+Option+R 运行文件中从开头到光标所在处的代码 Ctrl+Alt+B Command+Option+B 运行文件中从光标所在处到文件末尾的代码 Ctrl+Alt+E Command+Option+E 运行当前函数定义代码 Ctrl+Alt+F Command+Option+F 运行当前代码块 Ctrl+Alt+C Command+Option+C 运行下一个代码块 Ctrl+Alt+N Command+Option+N 执行一个外部文件中的代码 Ctrl+Shift+O Command+Shift+O 执行当前文件中的代码 Ctrl+Shift+S Command+Shift+S 执行当前文件中的代码（并输出） Ctrl+Shift+Enter Command+Shift+Enter 折叠选中代码 Alt+L Command+Option+L 打开选中代码 Shift+Alt+L Command+Shift+Option+L 折叠所有代码 Alt+0 Command+Option+0 打开所有代码 Shift+Alt+0 Command+Shift+Option+0 跳转到指定行 Shift+Alt+G Command+Shift+Option+G 跳转到 Shift+Alt+J Command+Shift+Option+J 切换tab Ctrl+Alt+Down Ctrl+Option+Down 切换到前一个tab Win: Ctrl+Alt+Left, Linux: Ctrl+PageUp Ctrl+Option+Left 切换到下一个tab Win: Ctrl+Alt+Right, Linux: Ctrl+PageDown Ctrl+Option+Right 切换到第一个tab Ctrl+Shift+Alt+Left Ctrl+Shift+Option+Left 切换到最后一个tab Ctrl+Shift+Alt+Right Ctrl+Shift+Option+Right 向前切换（类似浏览器→） Ctrl+F9 Command+F9 向后导航（类似浏览器←） Ctrl+F10 Command+F10 Reindent lines Ctrl+I Command+I 从选中的代码中提取函数 Ctrl+Shift+U Command+Shift+U 注释/取消注释 当前行/选中区域 Ctrl+Shift+C Command+Shift+C Reflow comment Ctrl+Shift+/ Command+Shift+/ Transpose Letters Ctrl+T Ctrl+T 向上/向下移动一行 Alt+Up/Down Option+Up/Down Copy Lines Up/Down Ctrl+Alt+Up/Down Command+Option+Up/Down Jump to Matching Brace/Paren Ctrl+P Ctrl+P 查找并替换 Ctrl+F Command+F 查找下一个 Win: F3, Linux: Ctrl+G Command+G 查找上一个 Win: Shift+F3, Linux: Ctrl+Shift+G Command+Shift+G 替换并查找 Ctrl+= Command+= 在文件中查找 Ctrl+F Command+F 拼写检查 F7 F7 Editing (Console and Source)编辑 Description Windows &amp; Linux Mac 撤销 Ctrl+Z Command+Z 重复上次操作 Ctrl+Shift+Z Command+Shift+Z 剪切 Ctrl+X Command+X 复制 Ctrl+C Command+C 粘贴 Ctrl+V Command+V 全选 Ctrl+A Command+A 跳转到单词 Ctrl+Left/Right Option+Left/Right 跳转到开头/结尾 Ctrl+Home/End or Ctrl+Up/Down Command+Home/End or Command+Up/Down 删除行 Ctrl+D Command+D 选择 Shift+[Arrow] Shift+[Arrow] 选择一个词 Ctrl+Shift+Left/Right Option+Shift+Left/Right 选中光标处到行首的内容 Shift+Home Command+Shift+Left or Shift+Home 选中光标处到行末的内容 Shift+End Command+Shift+Right or Shift+End Select Page Up/Down Shift+PageUp/PageDown Shift+PageUp/Down 选中到文件开始/末尾的内容 Ctrl+Shift+Home/End or Shift+Alt+Up/Down Command+Shift+Up/Down 删除左边的单词 Ctrl+Backspace Option+Backspace or Ctrl+Option+Backspace 删除右边的单词 Option+Delete 删除光标到行末的内容 Ctrl+K 删除光标到行首的内容 Option+Backspace 缩进 Tab (at beginning of line) Tab (at beginning of line) 取消缩进 Shift+Tab Shift+Tab Yank line up to cursor Ctrl+U Ctrl+U Yank line after cursor Ctrl+K Ctrl+K Insert currently yanked text Ctrl+Y Ctrl+Y Insert assignment operator Alt+- Option+- 查看光标处的函数帮助 F1 F1 查看光标处的函数代码 F2 F2 Completions (Console and Source)补全 Description Windows &amp; Linux Mac 自动完成 Tab or Ctrl+Space Tab or Command+Space 在历史命令中导航 Up/Down Up/Down 选定命令 Enter, Tab, or Right Enter, Tab, or Right 离开弹出的自动完成提示框 Esc Esc Views视图 Description Windows &amp; Linux Mac 跳转到文件/函数 Ctrl+. Ctrl+. 将光标定位到代码编辑器 Ctrl+1 Ctrl+1 将光标定位到控制台 Ctrl+2 Ctrl+2 将焦点定位到帮助 Ctrl+3 Ctrl+3 显示历史 Ctrl+4 Ctrl+4 显示文件 Ctrl+5 Ctrl+5 显示图像 Ctrl+6 Ctrl+6 显示包 Ctrl+7 Ctrl+7 显示工作空间 Ctrl+8 Ctrl+8 显示Git/SVN Ctrl+9 Ctrl+9 显示Build Ctrl+0 Ctrl+0 同步编辑器和PDF预览 Ctrl+F8 Command+F8 Build Description Windows &amp; Linux Mac 编译和重载 Ctrl+Shift+B Command+Shift+B 加载所有(devtools) Ctrl+Shift+L Command+Shift+L 检查包 Ctrl+Shift+E Command+Shift+E Plots绘图 Description Windows &amp; Linux Mac 上一个图像 Ctrl+Shift+PageUp Command+Shift+PageUp 下一个图像 Ctrl+Shift+PageDown Command+Shift+PageDown 显示操作者 Ctrl+Shift+M Command+Shift+M Git/SVN Description Windows &amp; Linux Mac 对比当前源码文件 Ctrl+Shift+D Command+Shift+D 提交修改 Ctrl+Shift+M Command+Shift+M 滚动查看不同 Ctrl+Up/Down Ctrl+Up/Down Stage/Unstage (Git) Spacebar Spacebar Stage/Unstage and move next (Git) Enter Enter 1.6 数据分析与挖掘流程 1.6.1 数据分析 数据分析是一个检查、清理、转换和建模数据的过程，目的是发现有用的信息，为结论提供依据，并起到辅助决策过程的作用。数据分析包含多个方面和多种方法，包括不同名称下的各种技术，并用于不同的商业、科学和社会科学领域。在当今的商业世界中，数据分析在做出更科学的决策和帮助企业更有效地运营方面发挥着重要作用。 1.6.2 数据分析流程 总体来说，数据分析是一个获取原始数据然后将其转化为对决策者用用的信息的过程，主要包含八个阶段. 数据要求：数据作为分析流程的输入时必须的，而且是根据指导分析的人(或将使用分析产生的最终产品的客户)的需求指定的。数据可以是数字的，也可以是分类的(比如数字的文本标签)。 数据收集：数据可以从各种来源收集，根据数据分析者所处的专业领域不同而变化。一般而言，原始数据可从环境中的传感器收集，包括交通摄像机、卫星、记录设备等，比如足球和篮球等体育数据可以通过摄像传感器记录保存。如果对数据的质量要求不高，也可以选择通过文档、图标等网络资源中获取二手乃至多手数据。 数据处理：最初获得的数据必须经过标准化处理以进行分析。例如，最常见数据处理要求就是以表格形式(称为结构化数据)将数据放入行和列中以供进一步分析，通常是通过使用电子表格或统计软件来进行。 数据清洗：经过数据处理后，所得到的结构化数据可能是不完整的，也可能存在冗余和错误等情况，这往往可能是因为数据输入和存储的方式存在问题，因此需要对数据进行数据清洗，从而防止和纠正这些错误。数据清洗常见的任务包括记录匹配、识别不准确数据、判断现有数据的整体质量、删除重复数据和识别异常数据。比如常见的异常值检测定量数据方法可以用于去除异常数据。 数据探索性分析：数据集被清理干净后，就可以开展多种类型的探索性分析。分析人员可以应用包括统计学方法在内的各种技术，称为探索性或者描述性数据分析，来理解所获得的数据中包含的基本信息。常见的可以利用最基本的数据统计量，即平均数、中位数和众数等来了解数据的基本统计学描述。 数据建模分析：可以利用相关数理统计模型或者机器学习算法来对数据分析，进而确定变量之间的关系，这是对数据进行深入建模分析的过程。一般来说，模型可以根据数据集中包含的其他变量来评估特定的变量，但是模型与数据之间往往会存在一定的偏差数据=模型+误差，例如使用回归模型探索某个变量与其他所有变量之间的相关关系，分析人员往往用残差来代表数据和模型之间的误差。 数据产品：数据产品一般是一种基于某种模型或算法的计算机应用程序，它接受数据输入并生成输出，然后将它们反馈给环境。例如，一个分析客户购买历史数据的应用程序，可以基于其底层的推荐算法为客户推荐其可能喜欢的其他商品。 数据交流：数据分析完成之后，可能以多种格式报告给需求方客户，以支持其相关决策。另一方面，客户可能会对数据分析的结果产生反馈，从而产生额外的数据分析需求，这也是为什么很多数据分析流程呈现周期性、迭代性特征。 1.6.3 数据挖掘 数据挖掘是在大规模数据集中提取和发现模式和规律的过程，是涉及机器学习、数理统计和数据库系统的交叉方法，也是计算机科学和统计学的一个跨学科交叉领域。数据挖掘总体目标是从数据集中提取潜在的信息和模式，并将信息转化为可理解的结构以供进一步使用。实际的数据挖掘任务是对大量数据进行半自动或自动分析，以提取以前未知的、有趣的模式，如数据集群发现(聚类分析)、异常记录(异常检测)和依赖性(关联规则挖掘、顺序模式挖掘)。数据分析最常用的六类任务分别是： 异常检测：异常检测又称异常值/偏差检测，需要识别出有待进一步调查的数据错误。 关联规则学习：关联规则学习是对依赖性建模的过程，用于探索变量之间的关系。比如，一家超市可能会收集有关顾客购买习惯的数据，然后用通过关联规则学习，可以确定哪些产品经常被一起购买，并将这些信息用于营销。 聚类：聚类是在不使用数据中的已知结构的条件下，发现数据中相似的集群或者社区的任务。 分类：分类是将已知结构一般化以应用于新数据的任务。例如，一个电子邮件程序可能根据历史垃圾邮件记录，试图将一封电子邮件分类为“合法”或“垃圾邮件”。 回归：回归试图找到函数，该函数在某种误差最小度量下对数据进行拟合建模，比兔线性回归和逻辑回归等。 总结：提供更紧凑的数据集表示，包括可视化和报告生成。 1.6.4 数据挖掘流程 按照跨行业数据挖掘标准流程(CRISP-DM)，一般数据挖掘的流程分成六个阶段，包括业务背景了解、数据理解、数据准备、建模、评价和部署。其基本过程与数据分析流程类似，这里不再赘述。 1.6.5 数据分析与数据挖掘的比较 数据分析和数据挖掘的区别在于，数据分析用于测试数据集上的模型和假设，例如，分析营销活动的有效性，并且数据分析往往不考虑数据量。相比之下，数据挖掘使用机器学习和统计模型来揭示大量数据中的秘密或隐藏模式，即数据挖掘一方面更侧重于发现未知模式，另一方面往往侧重于应用于大数据。 "],["数据基础.html", "第 2 章 数据基础 2.1 数据类型 2.2 控制语句 2.3 数据导入与导出", " 第 2 章 数据基础 2.1 数据类型 2.1.1 概述 数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。 变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式。 2.1.2 六种常见的数据类型 R语言中常见的数据类型有6种： 数据类型 示例 验证代码 输出结果 数值型（numeric） 5，10.5，999，2.3e-10（科学计数法） x &lt;- 100;class(x) [1] \"numeric\" 整数型（integer） 2L，34L，0L x &lt;- 2L;class(x) [1] \"integer\" 字符型（character） ‘a’ , ‘“good”, “TRUE”, ’100’ x &lt;- \"TRUE\";class(x) [1] \"character\" 逻辑型（logical） TRUE, FALSE x &lt;- TRUE;class(x) [1] \"logical\" 复数型（complex） 3 + 2i x &lt;- 3+2i;class(x) [1] \"complex\" 原始型（raw） “Hello”存储值为:48 65 6c 6c 6f x &lt;- charToRaw(\"Hello\");class(x) [1] \"raw\" 2.1.3 特殊：日期型（date） 除以上6种常见的数据类型外，我们经常会遇到时间序列数据，那就需要了解日期型（date）数据，最常用的日期型数据类型有两种： Date（仅存储日期） x &lt;- as.Date(&quot;2022-10-27&quot;) class(x) ## [1] &quot;Date&quot; POSIXct（同时存储日期和时间） y &lt;-as.POSIXct(&quot;2022-10-27 21:55&quot;) class(y) ## [1] &quot;POSIXct&quot; &quot;POSIXt&quot; 2.1.4 查看数据类型 如果想要查看数据的类型，可以使用class函数：class(x) 2.2 控制语句 编程语言最基本也是最常见的三种控制结构分别是顺序、分支和循环结构。在R语言中，顺序结构通过代码的前后顺序直接决定，而分支结构和循环结构就需要对应的控制语句来实现。 其中关于分支结构，R中最常见的分支控制语句就是if……else，用于对逻辑语句进行判断，从而决定执行不同的代码，实现逻辑分支。逻辑语句中最常见的形式就是比较，比如等于(=)，不等于(!=)，大于(&gt;)，大于等于(&gt;=)，小于()&lt; ，小于等于(&lt;=)。if……else中对应逻辑条件下的业务代码都需要放置于{}中，而且else必须和if条件分支对应的右花括号处于一行，否则将导致程序出现无法识别的错误。R语言可以通过ifelse()对分支语句进行简化，比如可以对下表中的if……else语句简化化为: ifelse(i&gt;3, print(\"Yes\"), print(\"No\"))。此外，ifelse()可以实现向量化，比如通过结合transform()函数对数据框中的每一个元素进行判别运算从而生成新列。 R中对循环逻辑的控制语句包括两种，最常用的一种是for循环，如下表所示，该循环的每次执行可以取出循环向量中的每一个元素，并执行花括号中的语句，直到所有的元素都取完为止。其中循环的向量不局限于连续型向量，还可以选择其他任意向量。另外一种循环是while循环，其通过设置一个判定条件，每次执行完循环体中的语句后都通过判断此条件来决定是否执行下一次循环，这种循环容易因条件设置不当而陷入“死循环”。R语言为循环逻辑的控制还提供了break语句和next语句，它们只能够用于循环结构中，其中break语句代表退出循环体，next语句代表跳过本次循环，直接进行下一次循环(的条件判断)。 2.3 数据导入与导出 2.3.1 数据导入 R中可导入各种数据源的数据，包括键盘、文本文件、Excel和Access、统计软件、数据库管理系统、专业数据库、网站和在线服务等。下面介绍几种常用的导入方式。 2.3.1.1 使用键盘输入数据 使用edit()函数会自动调用一个允许手动输入数据的文本编辑器。具体步骤如下： 创建一个空数据框（或矩阵），其中变量名和变量的模式需与理想中的最终数据集一致； 针对这个数据对象调用文本编辑器（如下图），输入你的数据，并将结果保存回此对象中。 mydata &lt;- data.frame(age=numeric(0),gender=character(0),weight=numeric(0)) mydata &lt;- edit(mydata) 需要特别注意的是，如果您的操作系统为macOS，需要前往https://www.xquartz.org/手动下载安装XQuartz，才能正常调用edit()函数。 2.3.1.2 读取Excel数据 R虽然可以导入SPSS、SAS和Stata软件的数据，但是最好的数据导入方法还是导入经过初步处理的原始数据，而不是导入可能经过另一种统计软件处理过的数据。 读取Excel数据可以使用read.xlsx()函数，但最好的方式则是将Excel转化为csv，然后将csv数据导入到R中。 Excel数据一般为.xlsx和.xls格式，可以通过文件-另存为-保存类型-选择保存为csv文件，然后将csv文件复制到R工作目录中去。 下面讲解怎么从csv文件中读取数据。 2.3.1.2.1 方法一：read.table()函数 可以使用read.table()函数将带分隔符的文本文件中导入R中。 read.table(file, header = FALSE,sep = &quot;&quot;, quote = &quot;\\&quot;&#39;&quot;, dec = &quot;.&quot;, numerals = c(&quot;allow.loss&quot;, &quot;warn.loss&quot;, &quot;no.loss&quot;), row.names, col.names, as.is = !stringsAsFactors, na.strings = &quot;NA&quot;,colClasses = NA, nrows = -1, skip = 0, check.names = TRUE, fill = !blank.lines.skip, strip.white = FALSE, blank.lines.skip = TRUE, comment.char = &quot;#&quot;,allowEscapes = FALSE, flush = FALSE, stringsAsFactors = default.stringsAsFactors(), fileEncoding = &quot;&quot;, encoding = &quot;unknown&quot;, text, skipNul = FALSE) 部分参数释义: file # 要读取的数据文件名(将文件名包含在”“内)。如果数据文件不在R工作目录里，需要使用全路径，所以建议放在工作目录中。 header # 逻辑值；数据文件的第一行是否为变量名； sep # 分开数据的分隔符；默认为空白”“。 使用sep=\",\"则读取用逗号分隔行内数据的文件； 使用sep=\"\\t\"则读取用制表符分割行内数据的文件。 quote # 指定用于包围字符型数据的字符，默认双引号(““)或单引号(’’) dec # 用来表示小数点的符号。 row.names # 指定行名的向量，或文件中一个变量的序号或名字,默认行号取为1, 2, 3…, col.names # 如果数据文件的第一行不包括变量名(header=FASLE)，则可以用col.names去指定一个包含变量名的字符向量。如果header=FALSE以及col.names选项被省略了，则变量分别命名为V1、V2、V3… as.is # 逻辑词；为FALSE，则将字符型变量转为因子型变量，为TRUE，则仍将其保留为字符型（TRUE）。也可以是逻辑型、数字型、或字符向量用来指定哪些列不需要转化为因子。 na.strings # 表示缺失值的字符向量。如na.strings=c(\"-9\",\"?\")，表示在读取数据时，会把-9和?值转换成NA。 colClasses # 指定各列变量数据类型的一个字符型向量。如colClasses=c(\"numeric\",\"numeric\",\"character\",\"NULL\",\"numeric\")，前两列读取为数值型，第三列读取为字符型，跳过第四列，第五列读取为数值型。如果数据有多余五列，colClasses的值会被循环。在读取大型文本文件时，指定colClasses参数可以提升处理速度。 nrows # 可以读取的最大行数(忽略负值)。 skip # 在读取数据前跳过的行数。 check.names # 如果为TRUE，则检查变量名是否在R中有效。 fill # 某些情况下，文件中各行的长度不相等，这个参数是个逻辑词，设置read.table在某些值缺失的情况下，是否自动添加空白值。 strip.white# 在sep指定情况下，为TRUE，则删除字符型变量前后多余空格。 stringsAsFactors # 逻辑词，标记处字符向量是否需要转化成因子。默认值是TRUE，除非它被colClases所覆盖。在处理大型文本文件时，设置成stringsAsFactors=FALSE可以提升处理速度。 text # 一个指定文字进行处理的字符串。如果text被设置了，file应该被留空。 blank.lines.skip # 逻辑词；为TRUE，忽略空白行。 comment.char # 默认情况下，comment.char把符号”#“后的任何文字当作注释；可以改变comment.char = \"符号\"来改变注释字符；如果数据中不包括任何注释，设置comment.char=\"\"可以加快读取速度。 flush # 逻辑词；在所有字段都已读入的情况下，是否应该跳到下一行。 allowEscapes # 逻辑词；设置是否使用转义符(如”“表示转一行)，还是直接读入。 encoding # 源文件的编码格式 2.3.1.2.2 方法二：read.csv()函数和read.csv2()函数 read.csv()函数和read.csv2()函数是read.table()函数的两种变形，这两个函数除了默认值与read.table()不同以外，其他的用法与read.table()完全相同。 两个函数的用法： read.csv(file, header = TRUE, sep = &quot;,&quot;, quote = &quot;\\&quot;&quot;, dec = &quot;.&quot;, fill = TRUE, comment.char = &quot;&quot;, ...) read.csv2(file, header = TRUE, sep = &quot;;&quot;, quote = &quot;\\&quot;&quot;, dec = &quot;,&quot;, fill = TRUE, comment.char = &quot;&quot;, ...) 从调用格式可看出，与read.table()不同，这两个函数默认参数都是header=TRUE。 3个函数的差别: read.table()函数：读取数据的分隔符为空格，小数点用点号”.”； read.csv()函数：读取数据的分隔符为逗号，小数点用点号”.”； read.csv2()函数：读取数据的分隔符为分号，小数点用逗号”,“。 2.3.1.3 读取SPSS数据 foreign包中的read.spss()函数和Hmisc包中的spss.get()函数都可以导入SPSS数据，spss.get()是对read.spss()的一个封装，可以自动设置后者的许多参数，让整个转换过程更加简单一致。 foreign包是基础包，默认安装，需要手动安装一下Hmisc包 2.3.1.3.1 read.spss()函数 read.spss(file, use.value.labels = TRUE, to.data.frame = FALSE, max.value.labels = Inf, trim.factor.names = FALSE, trim_values = TRUE, reencode = NA, use.missings = to.data.frame, sub = &quot;.&quot;, add.undeclared.levels = c(&quot;sort&quot;, &quot;append&quot;, &quot;no&quot;), duplicated.value.labels = c(&quot;append&quot;, &quot;condense&quot;), duplicated.value.labels.infix = &quot;_duplicated_&quot;, ...) 部分参数释义: file # 要读取的sav数据格式(将文件名包含在”“内)；如果文件不在工作目录，可能需要写入全部文件路径。 use.value.labels 逻辑词；默认为TRUE，表示将带有值标签的变量转换为R中的因子；为FALSE，则不转化为因子。 to.data.frame # 逻辑词；默认为FALSE，将数据读入到列表中；为TRUE，则将数据读入到数据框中。 2.3.1.3.2 spss.get()函数 spss.get(file, lowernames=FALSE, datevars = NULL, use.value.labels = TRUE, to.data.frame = TRUE, max.value.labels = Inf, force.single=TRUE, allow=NULL, charfactor=FALSE, reencode = NA) 部分参数释义: file # 要读取的sav数据格式(将文件名包含在”“内)；也可以是网络上的数据文件，以”http:/\"或\"https://\"格式表示； lowernames # 逻辑词；为TRUE时将变量名称转换为小写； datevars # 一个向量；指定哪些变量需要转换为R内部日期格式； use.value.labels # 逻辑词；默认TRUE，表示将带有值标签的变量转换为R中的因子；为FALSE，则不转化为因子。 to.data.frame # 逻辑词；默认为FALSE，将数据读入到列表中；为TRUE，则将数据读入到数据框中。 allow # 字符向量，默认情况下，变量名称中的下划线”_“将转换为点”.”。 2.3.1.4 读取Stata数据 可以使用read_stata()函数将stata数据导入到R中，调用格式为： read_stata(path,atomic.to.fac = FALSE,drop.labels = FALSE, enc = NULL,verbose = FALSE) 部分参数释义: path # 数据文件的路径 atomic.to.fac # 逻辑词，如为TRUE，则将数据集中的分类变量转换为因子 drop.labels # 逻辑词，如为TRUE，将删除没有使用的值标签 enc # 数据文件的字符编码 verbose # 逻辑词，如为TRUE，将显示导入数据的进度条 2.3.1.5 读取SAS数据 从SAS文件读入数据的方法有很多，常用比较可靠的方法是在SAS中使用PROC EXPORT将SAS数据集保存为一个逗号分隔的文本文件，再使用read.table()或read.csv()函数读取；也可以使用foreign包的read.ssd()函数或Hmisc包的sas.get()函数读取,具体方法与上述内容相似，在此不赘述了。 2.3.2 数据导出 R可以将R数据对象(通常是数据框或矩阵)导出到文本文件。常用的函数为write.table()函数 write.table(x, file = &quot;&quot;, append = FALSE, quote = TRUE, sep = &quot; &quot;, eol = &quot;\\n&quot;, na = &quot;NA&quot;, dec = &quot;.&quot;, row.names = TRUE, col.names = TRUE, qmethod = c(&quot;escape&quot;, &quot;double&quot;), fileEncoding = &quot;&quot;) 部分参数释义： x # 要导出的R中的对象 file # 字符值，要导出的R对象的文件名称 append # 逻辑词；为TRUE则将输出数据添加到现有文件的结尾；为FALSE则覆盖这个文件 quote # 逻辑词，默认为TRUE，表示将字符或因子值放入引号中；或为数值向量，指定哪些变量应该放在引号中 sep # 字符值，设置一行中分隔值的字符 eol # 字符值，设置放置在每行结尾处的字符 na # 表示缺失值NA的字符 dec # 表示小数点的字符 row.names # 逻辑词，默认为TRUE，设置输出中是否应该包括行名称；或数值向量，设置哪些行的名称应该输出 col.names # 逻辑词，默认为TRUE，设置输出中是否应该包括列名称；或字符向量，设置列名称 qmethod # 设置如何处理引用字符和因子字段中的引号。\"escape\"表示用反斜杠转义引号；double表示将引号转义为双引号(即把”转换成”“) "],["数据建模.html", "第 3 章 数据建模 3.1 关系统计", " 第 3 章 数据建模 3.1 关系统计 3.1.1 相关分析 3.1.1.1 概念 直线相关：是一种研究两个变量之前的线性相关关系（相关的方向和密切程度）的一种统计方法 注：相关系数等于0时，只能说明两变量间无直线关系，不能说两变量无关 3.1.1.2 相关系数及其计算 相关系数：又称Pearson积差相关系数，是说明具有直线相关关系的两个数值变量之间相关的方向和密切程度的统计量。 2.计算公式： \\[ r = \\frac{l_{XY}}{\\sqrt{l_{XX}l_{YY}}} = \\frac{\\sum (X-\\bar{X})(Y-\\bar{Y})}{\\sqrt{\\sum (X-\\bar{X})^2\\sum (Y-\\bar{Y})^2}} \\] 其中\\(l_{XY}\\)表示\\(X\\)与\\(Y\\)的离均差积和，\\(l_{XX}\\)表示\\(X\\)的离均差平方和，\\(l_{YY}\\)表示\\(Y\\)的离均差平方和。 相关系数是没有单位的，取值范围为\\([-1,1]\\). 当\\(r &gt; 0\\)时，两随机变量为正相关；当\\(r &lt;0\\)时，两随机变量为负相关; 当\\(|r| = 1\\)时，两随机变量完全相关；当\\(|r| = 0\\)时, 两随机变量无直线关系. 3.1.2 一元与多元回归 3.1.2.1 概念 1.回归：是分析研究变量与变量之间的关系的一种行为，也可以说是回归于事物本来的面目！ 2.回归分析：指的是确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法。 回归分析按照涉及的变量的多少，分为一元回归和多元回归分析；按照因变量的多少，可分为简单回归分析和多重回归分析；按照自变量和因变量之间的关系类型，可分为线性回归分析和非线性回归分析。 3.1.3 普通最小二乘法回归 普通最小二乘法回归（ordinary least squares，OLS）是一类服务于正态响应变量的模型框架。包括：简单线性回归、多项式回归和多元线性回归；OLS回归是目前最常见的统计分析方法。 ####简单线性回归模型 简单回归模型 \\[ y = \\beta_0 +\\beta_1x+u \\] 零条件均值假设下： \\[ E(u) = 0 \\\\ Cov(x,u) = E(xu) = 0 \\] 矩估计: \\[ \\frac{1}{n}\\sum_{i=1}^{n}(y_i-\\hat{\\beta}_0 -\\hat{\\beta}_1x_i) = 0 \\\\ \\frac{1}{n}\\sum_{i=1}^{n}x_i(y_i-\\hat{\\beta}_0 -\\hat{\\beta}_1x_i) = 0 \\] 得到估计的斜率： \\[ \\hat{\\beta}_1 = \\frac{\\sum_{i=1}^{n}(x_i-\\bar{x})(y_i-\\bar{y})}{\\sum_{i=1}{n}(x_i-\\bar{x})^2} \\] 定义总平方和(total sum of squares, SST)，解释平方和(explained sum of squares.SSE), 残差平方和(residual sum of squares, SSR): \\[ SST = \\sum_{i=1}{n}(y_i-\\bar{y})^2\\\\ SSE = \\sum_{i=1}{n}(\\hat{y}_i-\\bar{y})^2\\\\ SSR = \\sum_{i=1}{n}\\hat{u}_i^2\\\\ SST = SSE + SSR \\] 拟合优度： \\[ R^2 = SSE/SST = 1 - SSR/SST \\] 残差的标准误是残差平方和的均方根，用\\(s_e\\)表示，计算公式为： \\[ s_e = \\sqrt{\\frac{\\sum(y_i - \\hat{y_i})^2}{n - k - 1}} = \\sqrt{\\frac{SSE}{n - k - 1}} = \\sqrt{MSE} \\] 式中，k为自变量的个数，在一元线性回归中，n-k-1=n-2. \\(s_e\\)是度量各观测值在直线周围分散程度的一个统计量，它反映了实际观测值\\(y_i\\) 与回归估计值\\(\\hat{y}_i\\)之间的差异程度. \\(s_e\\)也是对误差项\\(\\epsilon\\)的标准差\\(\\sigma\\)的估计，它可以看作在排除了x对y的线性影响后，y随机波动大小的一个估计量. 从实际意义看，\\(s_e\\)反映了用估计的回归方程预测y时产生的预测误差大小各观测值越靠近直线，\\(s_e\\)就越小，根据回归方程进行预测也就越准确:若各观测值全部落在直线上，\\(s_e = 0\\),此时用x预测y是没有误差的. 3.1.3.1 多元回归分析 设因变量为\\(y\\),\\(k\\)个自变量分别为\\(x_1,x_2,\\ldots,x_k,\\)描述因变量\\(y\\)依赖于自变量\\(x_1,x_2,\\ldots,x_k\\)和误差项\\(\\epsilon\\)的方程称为多元线性回归模型, 一般形式为: \\[ y = \\beta_0+\\beta_1x_1+\\beta_2x_2+\\cdots+\\beta_kx_k + \\epsilon \\] 其中\\(\\beta_0,\\beta_1,\\ldots,\\beta_k\\)为模型参数。而\\(\\epsilon\\)是用$_0+_1x_1+_2x_2++_kx_k \\(去代替\\)y$所形成的误差。 一般在多元线性回归模型中，对误差项\\(\\epsilon\\)有三个基本假设： 正态性. \\(\\epsilon\\)是一个服从均值为0的正态分布的随机变量。 方差齐性. 对于任意自变量\\(x_1,x_2,\\ldots,x_k\\)的取值，\\(\\epsilon\\)的方差\\(\\sigma^2\\)都一个相同常值。 独立性. 对自变量不同取值得到的\\(\\epsilon\\)是独立的。 根据上面三个基本假设，称 \\[ E(y) = \\beta_0 + \\beta_1x_1 + \\beta_2x_2 + \\ldots + \\beta_kx_k \\] 为多元线性回归方程, 该方程描述了因变量\\(y\\)的期望与自变量\\(x_1,x_2,\\ldots,x_k\\)之间的关系。 多元回归模型中的回归参数\\(\\beta_0,\\beta_1,\\ldots,\\beta_k\\)是未知的，需要利用现有样本数据去估计，当用样本估计值\\(\\hat{\\beta}_0, \\hat{\\beta}_1,\\ldots, \\hat{\\beta}_k\\)去估计回归模型中的参数\\(\\beta_0, \\beta_1, \\beta_2, \\ldots, \\beta_k\\)时，就得到了估计的多元线性回归方程，其一般形式为 \\[ \\hat{y} = \\hat{\\beta}_0 + \\hat{\\beta}_1x_1 + \\ldots + \\hat{\\beta_k}x_k \\] 其中\\(\\hat{\\beta}_0, \\hat{\\beta}_1, \\ldots, \\hat{\\beta}_k\\) 为回归参数\\(\\beta_0, \\beta_1, \\ldots, \\beta_k\\)的估计值；而\\(\\hat{y}\\)是因变量\\(y\\)的估计值。我们记\\(\\hat{\\beta}_0, \\hat{\\beta}_1, \\ldots, \\hat{\\beta}_k\\)为偏回归系数. \\(\\hat{\\beta_i}\\)表示当\\(x_1,x_2,\\ldots,x_{i-1},x_{i+1},\\ldots,x_k\\)不变时，\\(x_i\\)每改变一个单位因变量\\(y\\)的平均改变量。 3.1.3.2 参数的最小二乘估计 对于多元线性回归模型中的参数\\(\\beta_0,\\beta_1,\\ldots,\\beta_k\\),我们仍然用最小二乘法来估计，即 \\[ P = \\sum (y_i - \\hat{y}_i)^2 = \\sum(y_i - \\hat{\\beta_0} - \\hat{\\beta}_1x_1 - \\cdots - \\hat{\\beta}_kx_k)^2 \\] 我们对其求最小值，即 \\[ \\begin{cases} \\frac{\\partial P}{\\partial \\beta_0}|_{\\beta_0 = \\hat{\\beta}_0} = 0 \\\\ \\frac{\\partial P}{\\partial \\beta_1}|_{\\beta_1 = \\hat{\\beta}_i} = 0, i =1,2,\\ldots,k \\end{cases} \\] ## 拟合优度和显著性检验 ### 模型的拟合优度 多元线性回归模型的拟合优度一般都是用多重决定系数来评估。 3.1.3.2.1 多重系数 在多元线性回归中，因变量的总误差平方和SST$ = (y_i-)^2\\(可以通过计算从而分成两个具有实际意义的求和项：回归平方和SSR\\) = (_i - )^2\\(与残差平方和SSE\\) = (y_i - _i)^2$. 而我们记： \\[ R^2 = \\frac{SSR}{SST} \\] 为多重决定系数，它是多元线性回归中回归平方和占总平方和的比例。\\(R^2\\)s是多元线性回归模型拟合优度的度量。 但是如果一个模型中增加一个自变量，即使这个自变量在统计上并不显著，\\(R^2\\)也会变大。因此，为了避免增加自变量而使得估计的\\(R^2\\)偏高，一般有调整的多重决定系数： \\[ R^2_a = 1 - (1 - R^2) \\times\\frac{n-1}{n-k-1} \\] 由于调整的多重决定系数不受模型自变量个数的影响，故在多元回归分析中一般使用其来评估回归模型的拟合优度。 3.1.3.2.2 估计标准误 在多元回归分析中的估计标准误是其残差的标准差，它是多元回归模型中误差项\\(\\epsilon\\)标准差\\(\\sigma\\)的一个估计量，它的基本形式为： \\[ s_e = \\sqrt{\\frac{\\sum(y_i - \\hat{y}_i)^2}{n - k - 1}} = \\sqrt{\\frac{SSE}{n - k - 1}} \\] 其中k为自变量的个数。 3.1.3.3 模型的显著性检验 3.1.4 多重共线性及其处理 当回归模型中使用多个自变量时，如果模型中两个或两个以上的自变量彼此相关，则称此回归模型中存在多重共线性 3.1.4.1 多重共线性及其识别 3.1.4.1.1 多重共线性所产生的问题 多重共线性会带来以下问题： 变量之间高度相关时，可能会造成回归结果的混乱，甚至会把分析带入歧途。 多重共线性可能对参数估计值的正负号产生较大的影响。 3.1.4.1.2 多重共线性的识别和处理 识别多重线性的方法如下： 对回归模型中各对自变量之间的相关系数进行检验 考察各回归系数的显著性 分析回归系数的正负号 用容忍度和方差膨胀因子来识别共线性 3.1.4.2 变量选择与逐步回归 在多元线性回归模型中，变量的选择方法有向前选择，向后剔除，逐步回归等。 3.1.4.2.1 向前选择 向前选择是从模型中没有自变量开始，按下列步骤选择自变量来拟合模型: 首先， 分别拟合因变量\\(y\\)对\\(k\\)个自变量\\((x_1,x_2,...,x_k)\\)的一元线性回归模型，共有\\(k\\)个，然后找出F统计量的值最大的(或P值最小的)模型及其自变量2i并将该自变量首先引人模型(如果所有模型均无统计上的显著性，则运算过程终止，没有模型被拟合). 其次，在模型已经引人\\(x_i\\)的基础上，再分别拟合引人模型外的k-1个自变量 \\((x_1,\\ldots ,x_{i-1},x_{i+1},\\ldots ,x_k)\\)的回归模型，即自变量组合为\\(x_i+ x_1,x_i+x_{i-1},x_i + x_{i+1},... ,x_i+x_k\\)的\\(k-1\\)个回归模型，然后分别考察这k-1个模型，挑选出F统计量的值最大的(或P值最小的)含有两个自变量的模型，并将使F值最大的(或P值最小的)那个自变量\\(x_j\\)引人模型.如果除\\(x_i\\)之外的\\(k-1\\)个自变量中没有一个是统计上显著的，则运算过程终止.如此反复进行，直至模型外的自变量均无统计显著性为止. 向前选择法的特点是:只要某个自变量被增加到模型中，这个变量就-定会保留在模型中. 3.1.4.2.2 向后剔除 与向前选择法相反，向后剔除的基本过程如下: 首先，拟合因变量对所有k个自变量的回归模型.然后考察\\(p(p&lt;k)\\)个去掉一个 自变量的模型(这些模型中的每一个都有\\(k-1\\)个自变量)，使模型的SSE值减小最小的自变量(F统计量的值最小或其P值最大)被挑选出来并从模型中剔除. 其次，考察\\(p-1\\)个去掉一一个自变量的模型(这些模型中的每一个都有\\(k-2\\)个自变量)，使模型的SSE值减小最少的自变量被挑选出来并从模型中剔除.如此反复进行，直至剔除一个自变量不会使SSE显著减小为止.这时，模型中所剩的自变量都是显著的. 向后剔除法的特点是:只要某个自变量被从模型中剔除，这个变量就不会再进人模型中. 3.1.4.2.3 逐步回归 逐步回归是避免多重共线性的另一种有效方法，它将上述两种方法结合起来筛 选自变量前两步与向前选择法相同，不过在新增加一个自变量后， 它会对模型中所者的变量重新进行考察，看看有没有可能别除某个自变量如果在新增加一个自变批房前面增加m的某个自变量对模型的贡献变得不显著，这个变量就会被剔除，按此方法不停地增加变量并考虑剔除之前增加的变量的可能性，直至增加变量已经不能导致SSE显著减少(这个过程可通过F检验来完成) 逐步回归法的特点是:在前面步骤中增加的自变量在后面的步骤中有可能被剔险而在前面步骤中剔除的自变量在后面的步骤中也可能重新进人到模型中 利用逐步回归选择自变量的标准不同，得到的最终模型也就不同R中的逐步回 归以赤池信息准则(Akaike’s information criterion,AIC)为选择标准，选择使AIC最小的变量建立模型、赤池信息准则也称为AIC准则，它由日本学者赤池于1973年提出，除应用于线性模型的变量筛选外，还应用于时间序列自回归模型阶数的确定、 AIC由两部分组成:一部分反映模型的拟合精度; 另一部分反映模型中参数的个数，即模型的繁简程度AIC的值越小，表示报合的模型精度越高而且越简洁当用最小二乘法报合模型时，计算公式为: \\[ AIC = n\\ln(\\frac{SSE}{n}) + 2p \\] 式中,n为样本量: p为模型中参数的个数(包括常数项). 3.1.5 相对重要性和模型比较 3.1.5.1 自变量的相对重要性 哪些自变量对因变量的预测相对来说更重要，哪些相对来说不重要，了解这一问题对建模会有一定的参考价值，如果各自变量之间独立，那么根据自变量与因变量之间的相关系数大小就可以对重要性做出排序，相关系数大的显然更重要。但实际问题中，各自变量之间往往有一定的相关性，这就会使评估变得复杂很多.评估自变量相对重要性的方法之一就是比较标准化回归系数(standardized regression cofitient). 标准化回归系数是将因变量和所有自变量都标准化后进行回归得到的回归系数.计算标准化回归系数时，首先将因变量和各个自变量进行标准化@处理，然后根据标 准化后的值进行回归，得到的方程称为标准化回归方程(standardized regression equartion),该方程中的回归系数就是标准化回归系数，用\\(\\overline{\\beta}\\)表示，\\(\\overline{\\beta}_i\\)的含义是:在其他自变量取值不变的条件下，自变量\\(x_i\\)每变动一个标准差，因变量平均变动\\(\\overline{\\beta}_i\\)个标准差。显然，\\(\\overline{\\beta}_i\\)的绝对值越大，则说明该自变量\\(x_i\\)对自变量的影响就越大，相对于其他自变量而言，他对因变量的预测也就越重要。 3.1.5.2 模型比较 在多元线性回归建模中，如果一个模型包含另一个模型的所有项，并且至少有一个额外项，称这两个模型是嵌套模型。在嵌套模型中，包含所有项的模型称为完全模型，相对完全模型较简单的模型称为简化模型。 进行上述检验的步骤是:首先，用最小二乘法拟合简化模型，并计算相应的残差平方和(\\(SSE_R\\));其次，拟合完全模型，并计算出它的残差平方和(\\(SSE_F\\));然后计算出一者的差值(\\(SSE_R一SSE_F\\))进行比较，如果二次项对模型有贡献，那么\\(SSE_R\\)应该比\\(SSE_F\\)小很多，二者相差越大，说明完全模型比简化模型提供了越多的信息。检验统计量： \\[ F = \\frac{(SSE_R - SSE_F)/(k - g)}{SSE_F/(n - k - 1)} ~ F(k - g, n - k - 1) \\] 完全模型中的参数个数(包含常数项)为\\((k+1)\\),简化模型中的参数个数为\\((g+1)\\).如果检验的P值很小，就拒绝\\(H_0\\),表示完全模型比简化模型的拟合效果要好;如果P值较大，不拒绝\\(H_0\\),表示简化模型和完全模型的拟合效果一样好.由于建模时将更多的自变量引入模型，不仅增加了建模的复杂性，而且可能造成解释上的困难因此，当不能拒绝\\(H_0\\)时，就考虑采用简化模型. 3.1.6 Logistic回归 Logistic回归之所以称为”回归”，是因为人们曾试图用线性回归的方式处理因变量仅有两个不同值的情况(假定因变量为y,自变量为\\(x_1,\\ldots,x_2,...,x_p\\)).在线性回归中，如果因变量η只有0和1两个值，即使用线性回归训练出模型，其预测值不会在0和1之间，更不会仅限于0和1两个值.此外，诸如正态分布等假定对于两个值的变量更不合适.因此 人们把因变量取两个值考虑成Bernoulli 试验Bernoulli(p), 等价于n= 1时的二项分布 Bernoulli(p),这里Beenoulli试验的”成功”的概率为p(比如p = P(y = 1).如果把P的优势(ood) p/(1 - p)的对数ln(p/(1 - p))(称为优势比(dds ratio))作为自变量的线性函数，这就是Logistic回归模型： \\[ ln(\\frac{p}{1-p}) = \\beta_0 + \\beta_1x_1 + \\beta_2x_2 + \\cdots +\\beta_px_p = X\\beta \\] 或者 \\[ p = \\frac{e^{X\\beta}}{1+e^{X\\beta}} \\] 实际上，Logistic回归是广义线性模型的一个特例。广义线性模型适用于因变量作为指数分布族的情况，其一般的模型因变量分布的期望E(y)的某个函数g(E(y))为自变量的线性组合： \\[ g(E(y)) = X\\beta \\] 这里的函数g称为连接函数. Logistic回归中的bernoulli分布的期望为p, 连接函数为对数优势\\(g(p) = ln(p/(1-p))\\). 3.1.6.1 分组数据的Logistics回归模型 针对0-1型因变量产生的问题，我们对回归模型应该做出两个方面的改进。 第一是回归函数应该改用限制在\\([0,1]\\)区间内的连续曲线，而不能再沿用直线回归方程。我们常用的函数为Sigmoid函数： \\[ f(x) =\\frac{e^x}{1+e^x} = \\frac{1}{1+e^{-x}} \\] 第二，因变量\\(y_i\\)本身只取0，1两个离散值，不适于直接作为回归模型中的因变量，由于回归函数\\(E(y_i) = \\pi_i = \\beta_0+\\beta_1x_i\\)表示在自变量为\\(x_i\\)的条件下\\(y_i\\)的平均值，而\\(y_i\\)是0-1型随机变量，因而\\(E(y_i) = \\pi_i\\)就是在自变量为\\(x_i\\)的条件下\\(y_i\\)等于1的比例. 3.1.6.2 未分组数据的Logistics回归模型 设\\(y\\)是0～1型变量，\\(x_1,x_2,\\cdots,x_p\\)是与\\(y\\)相关的确定性变量，n组观测数据为\\((x_{i1},x_{i2},\\cdots,x_{ip};y_i)(i=1,2,\\cdots,n)\\),其中\\(y_1,y_2,\\dots,y_n\\)是取值为0或1的随机变量，\\(y_i\\)与\\(x_{i1},x_{i2},\\cdots,x_{ip}\\)的关系如下 \\[ E(y_i) = \\pi_i = f(\\beta_0+\\beta_1x_{i1}+\\cdots+\\beta_px_{ip}) \\] 其中，函数\\(f(x)\\)是值域在\\([0,1]\\)区间内的单调增函数。对于logistic回归 \\[ f(x) = \\frac{e^x}{1+e^x} \\] 于是\\(y_i\\)是均值为\\(\\pi_i = f(\\beta_0+\\beta_1x_{i1}+\\cdots+\\beta_px_{ip})\\)的0-1型分布，概率函数为 \\[ P(y_i=1)=\\pi_i\\\\ P(y_i=0)=1-\\pi_i \\] 可以把\\(y_i\\)的概率函数合写为 \\[ P(y_i) = \\pi_i^{y_i}(1-\\pi_i)^{1-y_i},y_i=0,1,i=1,2,\\cdots,n \\] 于是，\\(y_1,y_2,\\cdots,y_n\\)的似然函数为 \\[ L = \\prod\\limits_{i=1}^{n}P(y_i) = \\prod\\limits_{i=1}^{n}\\pi_i^{y_i}(1-\\pi_i)^{1-y_i} \\] 对似然函数取自然对数，得 \\[ lnL = \\sum_{i=1}^{n}[y_iln\\pi_i+(1-y_i)ln(1-\\pi_i)]\\\\ = \\sum_{i=1}^{n}[y_iln\\frac{\\pi_i}{1-\\pi_i}+ln(1-\\pi_i)] \\] 对于logistic回归，将 \\[ \\pi_i = \\frac{exp(\\beta_0+\\beta_1x_{i1}+\\cdots+\\beta_px_{ip})}{1+exp(\\beta_0+\\beta_1x_{i1}+\\cdots+\\beta_px_{ip})} \\] 代入得 \\[ lnL = \\sum_{i=1}^{n}[y_i(\\beta_0+\\beta_1x_{i1}+\\cdots+\\beta_px_{ip}) - ln(1+ exp(\\beta_0+\\beta_1x_{i1}+\\cdots+\\beta_px_{ip}))] \\] 极大似然估计就是选取\\(\\beta_0,\\beta_1,\\beta_2,\\cdots,\\beta_p\\)的估计值\\(\\hat{\\beta}_0,\\hat{\\beta}_1,\\cdots,\\hat{\\beta}_p\\)使得上式达到最大。 "],["数据可视化.html", "第 4 章 数据可视化 4.1 R语言中的图形系统 4.2 ggplot2语法结构——七层结构 4.3 可视化图形的基本类型", " 第 4 章 数据可视化 4.1 R语言中的图形系统 R语言中主要包含了三种图形系统，分别是基于graphics、基于lattice和基于ggplot2的图形系统。其中基本图形系统通过graphics包来实现，而基于lattice包和基于ggplot2的图形系统则都是在grid包的基础之上实现的。R-base中已经包含了graphics、grid和lattice三个包，因此不需要另外下载，而ggplot2则需要使用者自行安装。作为R-base原生图形系统，graphics无需加载即可使用，而grid、lattice和ggplot2则需要加载才可使用。 graphics绘图的特点是从空白版面开始绘图，图中的每一个元素都需要绘图者进行设计，因此绘图时需要对要绘制的内容有较为清晰的认识和计划。从函数的角度而言，graphics的绘图一般主要包括两个步骤，第一步是选择合适的图形主体，比如散点图plot、分布图hist和箱线图boxplot等等，第二步是在绘图主体上进行进一步的修饰和美化。 grid包可以非常方便的控制图形基本单元，为编程者创造图形提供较大的方便。例如，grid包可以产生供编程者编辑的图形组件，这些图形组件可以被重复使用或重组，并通过grid.layout()等函数把图形输出到指定位置。grid包的局限在于其没有提供生成统计图形和完整绘图的函数，因此编程者往往不会直接使用grid包来分析和展示数据。 lattice基于grid包实现，可以在多个维度下展示数据，即通过所谓的栅栏(trellis)来对多元变量关系进行直观展示。相较于基本绘图系统，lattice直接在图形设备上进行绘图，相应的绘图函数会返回栅栏对象。在命令执行时，栅栏对象会被自动打印，因此看起来像是lattice()函数直接完成了绘图过程。 ggplot2提供了一种全面而新颖的绘图方式，这套图形语法将绘图过程归结为数据(data)、视觉映射(Aesthetics)、几何对象(Geometries)、分面(Facets)、统计变换(Statistics)、坐标系统(Coordinates)和主题(Theme)等一系列步骤，并通过各步骤间的灵活组合完成统计绘图。在ggplot2包中，加号(+)的引入是变革性的，因为其使得各图层之间可以进行灵活的组合。相较于R中基于graphics和lattice包的参数繁多的的绘图系统，ggplot2摒弃了诸多繁琐的细节，以“图层叠加”的简单绘图逻辑提供了人性化而又高质量的绘图方法。 这里以散点图、箱线图和直方图为例展示三种绘图系统的具体代码，如下表所示，其中df是一个包含height, class和distance三列的数据框，分别代表身高，班级和跳远距离： 图形语法 散点图 箱线图 直方图 graphics plot(df$height, df$distance) boxplot(distance~class, data=df, xlab=“class”, ylab=“distance”) hist(df$distance, breaks=5, ylim=(0, 40)) lattice xyplot(height~distance, df, col=“black”) bwplot(distance~class, df, xlab=“class”, par.setttings=canonical.theme(color=FALSE)) histogram(~distance, df, type=“count”, nint=5, col=““white”“) ggplot2 ggplot(df, aes(x=height, y=distance)) + geom_point() ggplot(df, aes(x=class, y=distance)) + geom_boxplot() ggplot(df, aes(SOD) + geom_histogram(bins=30, colour=“black”, fill=“white”)) 可以看到基于graphics和lattice的图形系统的不足在于参数繁多和绘图逻辑不清晰，而ggplot2的绘图逻辑清晰，设置灵活，因此本书将以ggplot2为主介绍R语言的数据可视化。 4.2 ggplot2语法结构——七层结构 4.2.1 第一层：数据（Data） 选择要分析的数据集 +ggplot(data = ) 4.2.2 第二层：视觉映射（Aesthetics） 视觉映射的目的是完成x轴变量和y轴变量的选取 所谓映射，就是数据集中的数据关联到相应的图形属性过程中一种对应关系。 +aes(x = , y = ) 4.2.3 第三层：几何对象（Geometries） 使用几何函数来指定变量如何在视觉上进行表示（使用点、条、线和阴影区，多边形） 选取何种几何函数主要根据研究变量的类型： 如果一个变量是类别变量，一个是连续变量，我们可以选择箱线图，条形图等； 若两个都是连续变量则可以选择散点图，抖动散点图等。 +geom_XXX(…) + … geom函数： 参考线 Reference line: horizontal, vertical and diagonal： 在图中添加参考线（有时称为规则），可以是水平线、垂线或对角线（指定斜率和截距），是对绘图进行注释的有用工具。 对角线 diagonal：geom_abline（） 水平线 horizontal：geom_hline（） 垂线 vertical：geom_vline（） Ribbons and area plots： 对于每个x值，geom_ribbon()显示一个由ymin和ymax定义的y区间。geom_area()是geom_ribbon()的一个特例，其中ymin被固定为0，y被用来代替ymax。 色带图（连续的x值所对应的y的范围）：geom_ribbon（） 面积图：geom_area（） 柱状图/条形图 Bar charts： ﻿有两种类型的条形图： 条形图的高度代表每组的案例数： geom_bar（） 条形图的高度代表数据中的数值：geom_col（） 二维热图 Heatmap of 2d bin counts： 将平面划分为矩形，计算每个矩形中的案例数量，然后（默认）将案例数量映射到矩形的填充物上。这是在存在过度绘图的情况下对geom_point()的一个有用的替代。 geom_bin_2d（） geom_bin2d（） 空白，什么也不画 Draw nothing: geom_blank（） 箱线图 A box and whiskers plot (in the style of Tukey)： 等高线图 2D contours of a 3D surface： geom_contour（） geom_contour_filled（） 计数重叠点 Count overlapping points： geom_count（） 垂直区间 Vertical intervals: lines, crossbars &amp; errorbars 表示由x、ymin和ymax定义的垂直区间的各种方法。每种情况都会画出一个单一的图形对象。 带水平中心线的盒子图：geom_crossbar（） 误差条：geom_errorbar（） 一条代表一个区间的竖直线：geom_linerange（） 一条代表一个区间的中间带点的竖直线：geom_pointrange（） 水平误差条 Horizontal error bars： geom_errorbarh（） 光滑密度图/平滑密度估计 Smoothed density estimates： geom_density（） 二维密度估计的等高线图 Contours of a 2D density estimate： geom_density_2d（） geom_density_2d_filled（） geom_density2d（） geom_density2d_filled（） 点直方图 Dot plot： 用点表示观测值的个数 geom_dotplot（） 绘制连续曲线 Draw a function as a continuous curve： 计算并绘制一个连续曲线的函数。调用该函数时，沿X轴均匀分布的数值的网格，其结果（默认情况下）是用直线绘制的。 geom_function（） 二维六边形热图 Hexagonal heatmap of 2d bin counts： 将平面划分为规则的六边形，计算每个六边形中的案例数量，然后（默认情况下）将案例数量映射到六边形填充物上。六边形填充避免了有时由geom_bin2d()的非常规则的排列产生的视觉伪影。 geom_hex（） 直方图和频率多边形图 Histograms and frequency polygons： 直方图（适用于连续变量）：geom_histogram（） 频率多边形图（适用于分类变量）：geom_freqpoly（） 抖动点 Jittered points： 给点添加扰动，减轻图形重叠问题 geom_jitter（） 基准地图里的多边形 Polygons from a reference map： geom_map（） 连接观测值 Connect observations： 线图（按x坐标的大小顺序依次连接各个观测值）： geom_line（） 轨迹图（按数据的原始顺序连接各个观测值）： geom_path（） 阶梯图（以阶梯形式连接各个观测值）： geom_step（） 散点图 Points： geom_point（） 多边形 Polygons： 相当于一个有填充的路径 geom_polygon（） qq图 A quantile-quantile plot： geom_qq（） geom_qq_line（） 添加分位数回归线 Quantile regression： geom_quantile（） 矩形图 Rectangles： 高效的矩形瓦片图 geom_raster（） 二维矩形图 geom_rect（） 瓦片图 geom_tile 边际地毯图 Rug plots in the margins： geom_rug（） 线段和曲线 Line segments and curves： 添加线段或箭头：geom_segment（） 添加曲线：geom_curve（） 绘制地图 Visualise sf objects： geom_sf（） geom_sf_label（） geom_sf_text（） 拟合曲线 Smoothed conditional means： 添加光滑的条件均值线 geom_smooth（） 由位置、方向和距离参数化的线段 Line segments parameterised by location, direction and distance： geom_spoke（） 文本 Text： 标签：geom_label（） 文本注释： geom_text（） 小提琴图 Violin plot： geom_violin（） 4.2.4 分面（facet） 以下元素与分面ggplots相关: 元素 设置器 描述 strip.background element_rect() 面板条的背景 strip.text element_text() 条状文本 strip.text.x element_text() 水平条状文本 strip.text.y element_text() 垂直条状文本 panel.margin unit() 切面之间的边距 panel.margin.x unit() 切面之间的空白(垂直) panel.margin.y unit() 切面之间的边距（水平） strip.text.x元素同时影响到facet_wrap()或facet_grid(); strip.text.y元素只影响到facet_grid()。 4.2.5 第五层：统计变换（stat） ggplot2的第四层是统计变换图层stat_xxx()，它通过一些统计变换方法得到数据的某些统计量，并可以在这些统计量的基础上进行绘图。比如stat_smooth()计算每一个x下的y的平均值，并基于所得到的平均值绘制平滑曲线，这与几何对象图层里的geom_smooth()功能类似。事实上，统计变换图层stat_xxx与几何对象图层geom_xxx关系密切，两者相互补充构成了ggplot2图层结构中的重要组成成分。许多几何对象绘制函数geom_xxx都需要统计变换函数stat_xxx作为前提，比如： stat_bin`(): geom_bar(), geom_freqpoly(), geom_histogram() stat_bin2d(): geom_bin2d() stat_bindot(): geom_dotplot() stat_binhex(): geom_hex() stat_quantile(): geom_quantile() stat_sum(): geom_count() stat_smooth(): geom_smooth() stat_boxplot`(): geom_boxplot() stat_contour`(): geom_contour() stat_qq:geom_qq 在日常使用ggplot2的过程中，我们很少直接调用上述这些统计变换函数来绘制相应的几何对象，而是使用相应的几何对象绘制函数geom_xxx()，比如geom_histogram()中封装了区间分割和频率统计功能，并在此基础上直接绘制直方图。但了解统计变换图层仍然有其必要性，一方面我们可以对所绘制对象的统计特性有更深的了解，另一方面数据的某些统计特性仍然无法通过几何对象图层表现出来，这时候统计变换图层就成为了几何对象图层的重要补充。这里我们重点关注那些无法通过几何对象图层直观表示的统计变换函数，并讨论如何利用这些统计变换函数来丰富图形内容，主要包括如下几种： stat_ecdf能够绘制经验累积分布函数(ECDF)，是分布的另一种可视化方法，与其他依赖密度的可视化(如geom_histogram())相比，经验累积分布函数不需要任何调优参数，并且可以处理连续变量和分类变量，但是需要更多的训练样本才能准确地解释数据分布。 stat_ellipse()能够基于Fox和Weisberg等人提出的方法绘制数据分布椭圆图。 stat_function基于已有数据计算并绘制连续的曲线。此函数需要x轴的间距均匀分布，并且默认使用另一条曲线绘制在当前图层上，因此可以比较方便地与其他曲线进行对比。 stat_summary可以在每一个给定的x或者y上计算一些比较直观的计数统计量,比如平均数和中位数等。 stat_summary2d, stat_summary_hex和stat_summary_bin()是更加灵活版本的stat_summary，可以在x和y等多个维度的组合下计算平均数和中位数等聚合统计量。 stat_sopke可以将角度和半径转化为位置 stat_unique可以去除所分析数据中的冗余样本 继续以上面所使用的篮球体育数据为例，我们进一步展示统计变换图层对数据统计学特征的直观展示： p &lt;- p + stat_ellipse() p 可以看到，在确定了数据、变量和几何对象后，我们通过stat_ellipse进一步对每一个球队数据的椭圆分布特征进行了美学呈现，而这是通过几何对象图层geom_xxx所无法完成的。 从上面的介绍中我们可以发现，统计变换图层与几何对象图层之间存在密不可分的关系。尽管我们在前面强调了geom_xxx在对数据进行某些方面的统计变换分析时面临诸多局限，但是这并不意味着统计变换图层可以替代几何对象图层。从数据的全角度展示角度而言，两者是相互依赖相辅相成的。所以我们在利用ggplot2绘图的的过程中，可以通过几何对象图层和统计变换图层的配合更加全面地展示数据内部的复杂关系。 4.2.6 第六层：坐标系统（Coordinate与scale） 坐标系统有两项主要工作: 将两个位置美学结合起来，在图上产生一个2d位置。位置美学被称为x和y，但它们被称为位置1和2可能更好，因为它们的含义取决于使用的坐标系。例如，在极坐标系统中，它们成为角度和半径（或半径和角度），而在地图中，它们成为纬度和经度。 在与面计的协调下，坐标系统绘制轴和面板背景。虽然标尺控制了出现在轴上的值，以及它们如何从数据映射到位置，但实际上是坐标系在绘制它们。这是因为它们的外观取决于坐标系：一个角轴看起来与一个X轴完全不同。 有两种类型的坐标系，线性坐标系统保留了几何体的形状。 coord_cartesian()：默认的笛卡尔坐标系，一个元素的2D位置是由X和Y的位置组合得到的。 coord_flip()：笛卡尔坐标系的x轴和y轴被翻转。 coord_fixed()：具有固定长宽比的笛卡尔坐标系。 另一方面，非线性坐标系可以改变形状：一条直线可能不再是直线，两点之间的最近距离可能不再是一条直线。 coord_map()/coord_quickmap()/coord_sf()：地图的投影。 coord_polar()：极坐标。 coord_trans()：在数据经过统计处理后，对x和y位置进行任意转换。 下面将对每个坐标系进行更详细的描述。 4.2.6.1 线性坐标系统 有三种线性坐标系统：coord_cartesian(),coord_flip(), coord_fixed()。 4.2.6.1.1 使用 coord_cartesian()放大绘图 coord_cartesian()有参数xlim和ylim。如当设置比例限制时，限制之外的任何数据都会被丢弃；但当设置坐标系限制时，我们仍然使用所有的数据，但我们只显示绘图的一个小区域。设置坐标系限制就像在放大镜下看图一样。 4.2.6.1.2 使用coord_flip()翻转坐标轴 大多数统计学和几何学假设你对以x值为条件的y值感兴趣（例如，平滑图、汇总图、箱形图、直线图）：在大多数统计模型中，x值被假设为无误差测量。如果你对以y为条件的x感兴趣（或者你只是想把图旋转90度），你可以使用coord_flip()来交换x轴和y轴。 4.2.6.1.3 用coord_fixed()进行等比例计算 coord_fixed()固定了x轴和y轴的长度比例。默认的比例确保x轴和y轴具有相等的比例：即沿x轴的1厘米与沿y轴的1厘米所代表的数据范围相同。长宽比也将被设置，以确保无论输出设备的形状如何，都能保持映射。更多的细节请参见coord_fixed()的文档。 4.2.6.2 非线性坐标系统 与线性坐标不同，非线性坐标可以改变几何体的形状。例如，在极坐标中，矩形变成了弧形；在地图投影中，两点之间的最短路径不一定是一条直线。 转变分两步进行。首先，每个几何体的参数化被改变为纯粹基于位置，而不是基于位置和尺寸。例如，一个酒吧可以表示为一个X位置（一个位置），一个高度和一个宽度（两个维度）。在非笛卡尔坐标系中解释高度和宽度是很困难的，因为一个矩形可能不再有恒定的高度和宽度，所以我们转换为一个纯粹基于位置的表示，即由四个角定义的多边形。这就有效地将所有几何体转换为点、线和多边形的组合。 一旦所有的几何体都有了基于位置的表示，下一步就是将每个位置转换成新的坐标系。转换点很容易，因为无论你在什么坐标系中，点仍然是一个点。线和多边形则比较难，因为一条直线在新的坐标系中可能不再是直线了。为了使问题具有可操作性，我们假设所有的坐标变换都是平滑的，也就是说，所有非常短的线在新的坐标系中仍然是非常短的直线。有了这个假设，我们就可以通过将直线和多边形分割成许多小线段并对每个线段进行转换。这个过程被称为 “咀嚼”。 4.2.6.2.1 用coord_trans()进行转换 coord_trans()的参数x和y应该是命名转化器或转化器对象的字符串。在尺度层面的转换发生在计算统计数据之前，不会改变几何体的形状。在坐标系层面的转换发生在统计数字被计算之后，并且确实会影响几何体的形状。同时使用这两种方法可以让我们在转换后的尺度上对数据进行建模，然后再进行反转换以进行解释：这是分析中的一种常见模式。 4.2.6.2.2 使用 coord_polar()的极坐标 使用极坐标可以产生饼状图和风玫瑰（来自条形几何体），以及雷达图（来自线状几何体）。极坐标经常被用于圆形数据，特别是时间或方向，但其感知特性并不好，因为小半径的角度比大半径的角度更难感知。theta参数决定了哪个位置变量被映射为角度（默认为x），哪个被映射为半径。 4.2.6.2.3 使用coord_map()进行地图投影 地图在本质上是球形数据的显示。简单地绘制原始经度和纬度会产生误导，所以我们必须对数据进行投影。有两种方法可以用ggplot2做到这一点。 coord_quickmap()是一个快速而肮脏的近似方法，它设置长宽比以确保1米的纬度和1米的经度在图的中间有相同的距离。对于较小的区域来说，这是一个合理的起点，而且非常快。 coord_map()使用mapproj包，(https://cran.r-project.org/package=mapproj)，做一个正式的地图投影。它需要和mapproj::mapproject()一样的参数来控制投影。它比coord_quickmap()慢得多，因为它必须咀嚼数据并转换每一块。 4.2.6.3 标尺（scale） 前面我们已经看到了，画图就是在做映射，不管是映射到不同的几何对象上，还是映射各种图形属性。这一小节介绍标尺，在对图形属性进行映射之后，使用标尺可以控制这些属性的显示方式，比如坐标刻度，可能通过标尺，将坐标进行对数变换；比如颜色属性，也可以通过标尺，进行改变。 ggplot(small)+geom_point(aes(x=carat, y=price, shape=cut, colour=color))+scale_y_log10()+scale_colour_manual(values=rainbow(7)) 4.2.7 第七层：主题（Theme） 4.2.7.1 简介 在本章中，你将学习如何使用ggplot2主题系统，它允许你对绘图的非数据元素进行精细控制。主题系统并不影响数据由几何体呈现的方式，也不影响数据由比例尺转换的方式。主题并不改变绘图的感知属性，但它们可以帮助你使绘图具有美感或与现有的风格指南相匹配。主题可以让你控制诸如字体、刻度线、面板条和背景等东西。 这种将控制分为数据和非数据部分的做法与基础和格子图形有很大的不同。在基础图形和网格图形中，大多数函数都需要大量的参数来指定数据和非数据的外观，这使得函数变得复杂和难以学习。 ggplot2采取了一种不同的方法：在创建绘图时，你决定数据如何显示，然后在它被创建后，你可以使用主题系统编辑渲染的每一个细节。 主题系统由四个主要部分组成: 主题元素指定你可以控制的非数据元素。例如，plot.title元素控制绘图标题的外观；axis.ticks.x，x轴上的刻度线；legend.key.height，图例中按键的高度。 每个元素都与一个元素函数相关联，该函数描述了该元素的视觉属性。例如，element_text() 设置文本元素的字体大小、颜色和面孔，如 plot.title。 theme()函数，允许你通过调用元素函数来覆盖默认的主题元素，比如theme(plot.title = element_text(color = \"red\"))。 完整的主题，如theme_grey()将所有的主题元素设置为旨在和谐地一起工作的值。 4.2.7.2 完整的主题 ggplot2有许多内置的主题。最重要的是theme_grey()，这是ggplot2的标志性主题，背景为浅灰色，网格线为白色。该主题的设计是为了在支持比较的同时将数据放在前面，这也是遵循45的建议。我们仍然可以看到网格线来帮助判断位置46，但它们的视觉影响很小，我们可以很容易地将它们 “调”出来。灰色的背景使绘图具有与文本相似的印刷颜色，确保图形与文件的流程相吻合，而不会因明亮的白色背景而显得突兀。最后，灰色背景创造了一个连续的色域，确保情节被视为一个单一的视觉实体。 ggplot2 1.1.0中还内置了其他七个主题。 theme_bw(): theme_grey()的一个变种，使用白色背景和灰色细网格线。 theme_linedraw():一个在白色背景上只有不同宽度的黑色线条的主题，让人联想到线条画。 theme_light()：与theme_linedraw()类似，但使用浅灰色的线条和坐标轴，以引导人们更多地关注数据。 theme_dark(): theme_light()的深色表妹，有类似的线条尺寸，但背景是深色的。有助于使细小的彩色线条突出出来。 theme_minimal():一个极简的主题，没有背景注释。 theme_classic():一个经典的主题，有X和Y轴线，没有网格线。 theme_void():一个完全空的主题。 所有的主题都有一个base_size参数，用来控制基本字体的大小。基本字体大小是轴标题所使用的大小：绘图标题通常较大（1.2倍），而刻度线和条形标签较小（0.8倍）。如果你想单独控制这些尺寸，你需要按照下面的描述修改各个元素。 除了每次应用主题外，你还可以用theme_set()改变默认主题。例如，如果你非常讨厌默认的灰色背景，可以运行theme_set(theme_bw())来为所有绘图使用白色背景。 你并不局限于ggplot2的内置主题。其他软件包，如Jeffrey Arnold的gthemes，甚至增加了更多。 完整的主题是一个很好的开始，但并没有给你很多的控制权。要修改单个元素，你需要使用theme()，用一个元素函数覆盖一个元素的默认设置。 4.2.7.3 修改主题组件 要修改一个单独的主题组件，你可以使用类似plot + theme(element.name = element_function()) 的代码。 有四种基本类型的内置元素函数：文本、线条、矩形和空白。每个元素函数都有一组参数来控制其外观。 element_text() 绘制标签和标题。你可以控制字体family, face, colour, size (以点为单位), hjust, vjust, angle (以度为单位) 和 lineheight (与字体大小的比例)。关于这些参数的更多细节可以在vignette(\"ggplot2-specs\")中找到。设置字体面孔是特别具有挑战性的。 你可以用margin参数和margin()函数来控制文本周围的边距。 margin()有四个参数：在文本的顶部、右侧、底部和左侧增加的空间量（单位：点）,任何没有指定的元素都默认为0。 element_line()绘制以color、size和linetype为参数的线条。 element_rect()绘制矩形，主要用于背景，参数为fill颜色和边界color、size和linetype。 element_blank()不画任何东西。如果你不希望画任何东西，也不希望为该元素分配空间，就使用这个方法。下面的例子使用 element_blank() 来逐步抑制我们不感兴趣的元素的出现。请注意绘图是如何自动收回这些元素之前所使用的空间的：如果你不希望发生这种情况（也许是因为它们需要与页面上的其他绘图保持一致），请使用color = NA, fill = NA来创建不可见的元素，但仍然占用空间。 其他一些设置需要网格单位。用unit(1, \"cm\")或unit(0.25, \"in\")创建它们。 要修改未来所有情节的主题元素，请使用theme_update()。它返回之前的主题设置，所以你可以在完成后轻松地恢复原来的参数。 4.2.7.4 主题元素 大约有40个独特的元素来控制绘图的外观。它们可以粗略地分为四类：图形、轴、图例、面板。下面将依次描述每一种。 4.2.7.4.1 图形元素 有些元素会影响整个绘图: 元素 设置器 描述 plot.background element_rect() 绘图背景 plot.title element_text() 绘图标题 plot.margin margin() 图形周围的边距 plot.background绘制一个矩形，覆盖在绘图的其他部分。默认情况下，ggplot2使用白色背景，以确保绘图在任何地方都可以使用（例如，即使你保存为png格式并放在黑色背景的幻灯片上）。当导出绘图用于其他系统时，你可能想用fill = NA使背景透明。同样，如果你在一个已经有边距的系统中嵌入绘图，你可能想取消内置的边距。请注意，如果你想在绘图周围画一个边框，一个小的边框仍然是必要的。 4.2.7.4.2 轴元素 轴元素控制轴的外观: 元素 设置器 描述 axis.line element_line() 与轴平行的线（在默认主题中隐藏） axis.text element_text() 打勾标签 axis.text.x element_text() x轴刻度标签 axis.text.y element_text() y轴刻度线标签 axis.title element_text() 轴标题 axis.title.x element_text() x轴标题 axis.title.y element_text() y轴标题 axis.ticks element_line() 轴刻度线 axis.ticks.length unit() 勾号的长度 注意，axis.text（和axis.title）有三种形式：axis.text、axis.text.x和axis.text.y。如果你想同时修改两个轴的属性，请使用第一种形式：任何你没有在axis.text.x和axis.text.y中明确设置的属性都将从axis.text中继承下来。 最常见的调整是旋转X轴的标签，以避免长的标签重叠。如果你这样做，注意负的角度往往看起来最好，你应该设置hjust=0，vjust=1。 4.2.7.4.3 图例元素 图例元素控制所有图例的外观。你也可以通过修改guide_legend()或guide_colourbar()中的相同元素来修改单个图例的外观。 元素 设置器 描述 legend.background element_rect() 图例背景 legend.key element_rect() 图例键的背景 legend.key.size unit() 图例键的大小 legend.key.height unit() 图例键高度 legend.key.width unit() 图例键的宽度 legend.margin unit() 图例边距 legend.text element_text() 图例标签 legend.text.align 0-1 图例标签对齐（0=右，1=左） legend.title element_text() 图例名称 legend.title.align 0-1 图例名称对齐（0=右，1=左） 还有四个属性控制图例如何在绘图的上下文中布局（legend.position, legend.direction, legend.justification, legend.box）。 4.2.7.4.4 面板元素 面板元素控制绘图面板的外观: 元素 设置器 描述 panel.background element_rect() 面板背景（在数据下） panel.border element_rect() 面板边框(在数据上方) panel.grid.major element_line() 主要网格线 panel.grid.major.x element_line() 垂直主要网格线 panel.grid.major.y element_line() 水平的主要网格线 panel.grid.minor element_line() 次要网格线 panel.grid.minor.x element_line() 垂直的次要网格线 panel.grid.minor.y element_line() 水平的次要网格线 aspect.ratio numberic 绘图长宽比 panel.background和panel.border的主要区别是，背景是在数据下面绘制的，而边框是在数据上面绘制的。由于这个原因，在覆盖panel.border时，你总是需要指定fill = NA。 4.3 可视化图形的基本类型 4.3.1 对比图 lm &lt;- read.xlsx(&quot;data/AA.xlsx&quot;) str(lm) #解构数据集 ## &#39;data.frame&#39;: 3798 obs. of 43 variables: ## $ MatchID : chr &quot;41188.5vs3&quot; &quot;41188.5vs3&quot; &quot;40986.5vs14&quot; &quot;40986.5vs14&quot; ... ## $ MatchDate : num 41188 41188 40986 40986 41076 ... ## $ Season : num 2012 2012 2012 2012 2012 ... ## $ Month : num 10 10 3 3 6 6 9 9 6 6 ... ## $ Phase : num 10 10 3 3 6 6 9 9 6 6 ... ## $ Location : chr &quot;Home&quot; &quot;AWAY&quot; &quot;Home&quot; &quot;AWAY&quot; ... ## $ TeamRank : num 5 3 5 14 5 7 5 1 5 11 ... ## $ Team : chr &quot;DalianAerbin&quot; &quot;BeijingGuoan&quot; &quot;DalianAerbin&quot; &quot;DalianShide&quot; ... ## $ OppRank : num 3 5 14 5 7 5 1 5 11 5 ... ## $ Opposition : chr &quot;BeijingGuoan&quot; &quot;DalianAerbin&quot; &quot;DalianShide&quot; &quot;DalianAerbin&quot; ... ## $ BP : num 49 51 54 46 58 ... ## $ GoalScored : num 3 1 3 3 2 1 0 0 1 1 ... ## $ GoalAgainst : num 1 3 3 3 1 2 0 0 1 1 ... ## $ Result : num 3 0 1 1 3 0 1 1 1 1 ... ## $ ResultR : num 0 3 1 1 0 3 1 1 1 1 ... ## $ Foul : num 20 20 18 16 20 15 19 20 22 11 ... ## $ Corner : num 1 3 11 3 4 3 4 3 2 4 ... ## $ Offside : num 3 4 0 5 1 0 3 1 3 2 ... ## $ YellowCard : num 3 3 0 2 2 3 1 2 2 3 ... ## $ RedCard : num 0 0 0 0 0 1 0 0 0 0 ... ## $ Shot : num 13 13 16 9 18 7 6 13 13 12 ... ## $ ShotAcc : num 61.5 38.5 43.8 33.3 44.4 ... ## $ Pass : num 437 510 464 394 478 331 414 577 512 357 ... ## $ PassAcc : num 65.2 70.6 62.1 54.1 72 ... ## $ FwdPass : num 322 342 333 303 317 234 286 394 363 257 ... ## $ FwdPassAcc : num 59.6 62 57.1 48.2 63.4 ... ## $ Cross : num 8 20 33 18 15 11 14 18 18 17 ... ## $ CrossAcc : num 25 15 27.3 16.7 13.3 ... ## $ GroundDuel : num 57 59 42 42 27 27 41 41 26 26 ... ## $ GroundDuelWon: num 50.9 49.1 50 50 59.3 ... ## $ AirDuel : num 31 31 64 64 38 38 46 46 34 34 ... ## $ AirDuelWon : num 64.5 35.5 51.6 48.4 47.4 ... ## $ Tackle : num 13 25 19 28 25 22 14 18 13 20 ... ## $ TackleWon : num 53.9 44 73.7 57.1 64 ... ## $ TD : num 107351 105927 117324 112010 102903 ... ## $ SprintE : num 61.6 64.9 88 82.5 71.5 73.7 53.9 80.3 69.3 79.2 ... ## $ SprintD : num 1231 1202 1571 1522 1637 ... ## $ HSRE : num 354 348 490 387 343 ... ## $ HSRD : num 4950 4865 7203 6044 5573 ... ## $ HIRE : num 416 412 578 470 414 ... ## $ HIRD : num 6181 6068 8774 7567 7208 ... ## $ MSRD : num 14479 14866 18417 16255 12714 ... ## $ LSRD : num 86691 84993 90133 88188 82980 ... lm_subset = lm[lm$Season == 2018 | lm$Season == 2019, ] lm_subset_agr = aggregate(lm_subset[, 11:ncol(lm_subset)], list(lm_subset$Location), FUN=mean) lm_subset_agr = lm_subset_agr[, c(&quot;BP&quot;, &quot;Foul&quot;, &quot;Corner&quot;, &quot;Offside&quot;, &quot;YellowCard&quot;, &quot;ShotAcc&quot;, &quot;PassAcc&quot;, &quot;FwdPassAcc&quot;, &quot;CrossAcc&quot;, &quot;GroundDuelWon&quot;, &quot;AirDuelWon&quot;, &quot;TackleWon&quot;)] lm_subset_agr[, &quot;group&quot;] = c(&quot;AWAY&quot;, &quot;HOME&quot;) lm_max = lapply(lm_subset[, c(&quot;BP&quot;, &quot;Foul&quot;, &quot;Corner&quot;, &quot;Offside&quot;, &quot;YellowCard&quot;, &quot;ShotAcc&quot;, &quot;PassAcc&quot;, &quot;FwdPassAcc&quot;, &quot;CrossAcc&quot;, &quot;GroundDuelWon&quot;, &quot;AirDuelWon&quot;, &quot;TackleWon&quot;)], max) lm_max = as.vector(unlist(lm_max)) 绘制雷达图 ggradar2::ggradar2(lm_subset_agr, fullscore = rep(80, ncol(lm_subset_agr)-1), grid.min = 0, grid.max = 1, grid.label.size = 6, gridline.label = seq(0, 80, 10), gridline.label.type=&quot;numeric&quot;, axis.label.size = 6, legend.text.size = 10, axis.label.offset=1.05, group.line.width = 1, group.point.size = 2) ggradar2::ggradar2(lm_subset_agr, fullscore = lm_max, grid.min = 0, grid.max = 1, grid.label.size = 6, gridline.label = seq(0, 100, 10), gridline.label.type=&quot;percentage&quot;, axis.label.size = 6, legend.text.size = 10, axis.label.offset=1.05, group.line.width = 1, group.point.size = 2) 绘制哑铃图 将数据转化为指定的格式 lm_subset_agr_t = as.data.frame(t(lm_subset_agr)[-ncol(lm_subset_agr),]) colnames(lm_subset_agr_t) = c(&quot;AWAY&quot;, &quot;HOME&quot;) lm_subset_agr_t[&quot;Score&quot;] = rownames(lm_subset_agr_t) lm_subset_agr_melt = as.data.frame(melt(as.data.table(lm_subset_agr_t), id=&quot;Score&quot;)) lm_subset_agr_melt[, &quot;value&quot;] = as.numeric(lm_subset_agr_melt[, &quot;value&quot;]) lm_subset_agr_melt ## Score variable value ## 1 BP AWAY 48.949220 ## 2 Foul AWAY 14.887950 ## 3 Corner AWAY 4.530655 ## 4 Offside AWAY 1.678647 ## 5 YellowCard AWAY 2.141649 ## 6 ShotAcc AWAY 36.607760 ## 7 PassAcc AWAY 72.412160 ## 8 FwdPassAcc AWAY 65.815010 ## 9 CrossAcc AWAY 23.496150 ## 10 GroundDuelWon AWAY 50.239110 ## 11 AirDuelWon AWAY 48.886870 ## 12 TackleWon AWAY 54.870060 ## 13 BP HOME 51.050780 ## 14 Foul HOME 14.393230 ## 15 Corner HOME 5.452431 ## 16 Offside HOME 1.780127 ## 17 YellowCard HOME 1.771670 ## 18 ShotAcc HOME 38.373340 ## 19 PassAcc HOME 73.861820 ## 20 FwdPassAcc HOME 67.629750 ## 21 CrossAcc HOME 25.541040 ## 22 GroundDuelWon HOME 49.761040 ## 23 AirDuelWon HOME 51.113340 ## 24 TackleWon HOME 54.320700 哑铃图实际上是点图和线图的组合 order = as.vector(lm_subset_agr_t[&quot;Score&quot;]) ggplot(lm_subset_agr_melt, aes(x=value, y=Score)) + geom_line(aes(group=Score)) + geom_point(aes(color=variable, size=value)) + labs(x=&quot;&quot;, y=&quot;&quot;) + guides(size=&quot;none&quot;) order = lm_subset_agr_t[, &quot;Score&quot;] ggplot(lm_subset_agr_melt, aes(x=value, y=Score)) + geom_line(aes(group=Score)) + geom_point(aes(color=variable), size=3) + labs(x=&quot;&quot;, y=&quot;&quot;) 绘制柱状图 将数据转化为指定的格式 colnames(lm_subset_agr_melt) = c(&quot;Score&quot;, &quot;Position&quot;, &quot;Value&quot;) ggplot(lm_subset_agr_melt, aes(x=Score,y=Value,fill=Position)) + geom_bar(position=&quot;dodge&quot;, stat=&quot;identity&quot;) + ylim(0, 80) + labs(x=&quot;&quot;, y=&quot;&quot;)+ coord_flip() "],["数据交流.html", "第 5 章 数据交流 5.1 R markdown 5.2 R shiny 5.3 R bookdown 5.4 R blogdown（博客） 5.5 R的个人简历制作 5.6 基于 R 语言的 Quarto 文档教程（前沿知识）", " 第 5 章 数据交流 5.1 R markdown R markdown可以生成可重复性报告，是R语言社区重要的交流工具。在学习R markdown之前，我们首先需要了解一下Markdown。 5.1.1 Markdown介绍 Markdown是一种轻量级标记语言，可以使用它在纯文本文档添加格式化元素。Markdown由John Gruber在2004年创建，目前是世界上最流行的标记语言之一。与常见的office文本编辑器(如Microsoft word等)不同，在Markdown中对文本格式的更改并不是立即可见的。Markdown的运行逻辑是：在创建Markdown格式的文件时，用户可以在纯文本中添加Markdown语法，以指示哪些单词和短语应该以何种方式进行格式化。 例如，要表示一级标题，我们可以在一级标题前面添加符号#(例如# 一级标题)。或者想让一个短语加粗，我们可以在短语前面和后面各加两个星号(例如，**这个文本是加粗的**) 5.1.2 Markdown的优越性 前面提到，Markdown已经是世界上最流行的轻量级标记语言之一。你可能会问，常见的所见即所得文本编辑器不是更好吗？为什么要使用Markdown呢？其相对于Microsoft word等一类的文本编辑器有何优越性呢？事实上，Markdown确实存在其诸多优越性，主要体现在如下五个方面： Markdown几乎可以用于任何文本编辑场景。包括创建网站、文档、笔记、书籍、演示文稿、电子邮件信息和技术文档等。 Markdown拥有极强的可移植性。包含markdown格式文本的文件几乎可以使用任何应用程序打开。因此如果你不喜欢当前的Markdown应用程序，你可以将Markdown文件导入至另一个Markdown应用程序。相比较而言，Microsoft word等文字处理应用程序将内容锁定为专有文件格式，为处理文本带来诸多不便。 Markdown拥有极强的跨平台特性。因此，可以在任何操作系统的设备上创建markdown格式的文本并编辑。 Markdown具有更加可靠的可持续性。既是当前的Markdown应用程序在将来某个时候停止工作，我们仍然可以使用文本编辑应用程序呈现和阅读markdown格式的文本。当涉及到书籍、论文和其他需要无限期保存的文件时，这是一个重要的因素。 Markdown使用范围广。我们几乎可以在任何地方看见Markdown的存在，像Reddit和GitHub这样的网站支持Markdown语法，许多桌面和基于网络的应用程序也支持它，用户还可以在macOS, Windows, Linux, iOS和Android等操作系统的设备上选择众多Markdown应用程序进行使用，而且还有一些基于web的应用程序专门为Markdown编写而设计。 根据所使用应用程序的不同，用户在使用Markdown时可能无法实时预览格式化的文档。但是没关系，根据Gruber的说法，Markdown语法被设计成可读且不引人注目的，因此Markdown文件中的文本即使没有呈现也可以被轻松阅读。 5.1.3 Markdown语法介绍 Markdown提供了多样全面的格式化选项，如下表所示： 格式化选项 Markdown语法 标题 # 一级标题## 二级标题### 三级标题 加粗 **加粗字体** 斜体 *倾斜字体* 引用 &gt; 引用 有序列表 1. 第一2. 第二3. 第三 无序列表 - 第一- 第二- 第三 代码 `print(“你好,世界”)` 超链接 [超链接](https://www.tsinghua.edu.cn/) 图片 ![图1](image.jpg) 表格 | 字段1 | 字段2 | | --- | --- | | 内容1 | 内容2 | 这里我们只是对Markdown的一些常见语法进行了基本介绍，关于Markdown语法的系统性学习请读者自行参考相关拓展资料。 5.1.4 从Markdown到R markdown Markdown虽然能够对文本轻松进行格式化操作，但是却无法直接运行R代码。于是，为了方便R社区中代码展示和文本格式化的双重需求，R markdown应运而生。R markdown集成了Markdown的内部语法，能够保留Markdown语法进行文本格式化，并在此基础上同时允许直接运行R代码块、展示运行结果和格式化代码块运行结果。用户可以通过如下方式插入并运行R代码块: 代码块头部花括号内可以设置代码块展示选项，相应的参数包括： echo：在报告中是否展示代码块，默认为TRUE include: 在报告中是否展示代码块以及代码运行的结果，默认为TRUE eval: 是否运行代码块，默认为TRUE tidy: 是否在显示代码的时候进行formatR对R源代码进行格式化处理，默认为FALSE warning: 是否在报告中显示警告信息，默认为FALSE error: 发生错误时是否继续运行代码块，默认为FALSE results: 该参数用于控制文本输出是否显示以及如何显示,有四个选项，包括markup, asis, hold和hide。markup选项代表对输出做一定的修饰，比如对输出的向量加上代码块的符号，是默认选项；asis是非常有用的选项，可以在代码结果中引入Markdown语法，代码的输出结果可以生成标题；hold会将代码的输出文本收集起来，并在文件最后进行输出；hide表示隐藏文本输出。 fig.show：该参数用于控制图片输出是否显示以及如何显示，也有四个选项，包括asis, hold, hide和animate。其中asis是默认选项，即显示图片并将其放置在代码生成的位置；hold和hide的含义同上；animate选项可以将生成的多幅图片转换为动画。 fig.height：控制输出图片的物理高度 fig.width：控制输出图片的物理宽度 out.height：控制输出图片的相对显示高度 out.width：控制输出图片的相对显示宽度 完成R markdown的编写后，我们可以在文件的头部添加标题、作者、日期和输出格式等选项，其中输出支持html，pdf和word等多种格式。比如如下的设置标明了作者信息并指定输出格式为html： --- title: &quot;R markdown&quot; author: &quot;Tsinghua University&quot; date: &quot;2022-10-26&quot; output: html_document --- 5.2 R shiny Shiny是R中的一种Web开发框架，使得R的使用者不必太了解css、js只需要了解一些html的知识就可以快速完成web开发，且shiny包集成了bootstrap、jquery、ajax等特性，极大解放了作为统计语言的R的生产力。使得非传统程序员的R使用者不必依赖于前端、后端工程师就可以自己依照业务完成一些简单的数据可视化工作，快速验证想法的可靠性。 5.3 R bookdown 5.3.1 介绍 R的bookdown扩展包(https://github.com/rstudio/bookdown) 是继knitr和rmarkdown扩展包之后， 另一个增强markdown格式的扩展， 使得Rmd格式可以支持公式、定理、图表自动编号和引用、链接， 文献引用和链接等适用于编写书籍的功能。 在bookdown的管理下一本书的内容可以分解成多个Rmd文件， 其中可以有可执行的R代码， R代码生成的文字结果、表格、图形可以自动插入到生成的内容中， 表格和图形可以是浮动排版的。 输出格式主要支持gitbook格式的网页图书， 这种图书在左侧显示目录， 右侧显示内容， 并可以自动链接到上一章和下一章； 通过单独安装的LaTeX编译器支持将书籍转换为一个PDF文件， 支持中文； 可以生成ePub等格式的电子书。 主要用于编写有多个章节的书籍， 也可以用来生成单一文件的研究报告。 建议使用RStudio集成环境制作这样的图书， 该软件内建了一键编译整本书的功能。 需要安装bookdown扩展包的最新版本。 bookdown扩展包现在还比较新， 还有一些BUG， 所以尽可能使用最新版的bookdown扩展包并且及时更新RStudio软件。 查看编译的网站建议使用Google Chrome浏览器， 此浏览器对gitbook的支持较好。 为了新写一本书或者从已有的书转换， 最简单的做法是从bookdown的网站下载bookdown配套的例书的zip文件 (见https://github.com/rstudio/bookdown-demo)， 将其解压到本地硬盘某个子目录， 然后修改其中的内容适应自己的书的需要。 因为中文需要一些特殊的设置， 以及在网络条件不好的条件下支持数学公式显示， 本书作者提供了一个粗浅的中文书bookdown模板， 下载链接为: bookdown-template-v0-6.zip 其中的CBook子目录包含了所需的中文书模板， CArticle子目录包含了论文格式模板， 其它子目录有一些别的模板， 为了在本地支持网页中的数学公式显示还有一个MathJax目录。 参见其中的readme.txt说明文件。 5.3.2 章节结构 除了index.Rmd文件, 项目中每个.Rmd文件都作为一章。 每个.Rmd文件第一行， 应该是以一个井号和空格开头的一级标题, 后面再加空格然后有大括号内以井号开头的章标签， 这些章标签去掉井号后会作为生成的HTML文件的名字， 所以一定要有章标签， 而且章节标签在全书中都不要重复以免冲突。 文件内可以用两个井号和一个空格开始的行表示节标题， 最后也应该有大括号内以井号开头的节标签, 使用bookdown写书， 一般每章不要太长， 否则编译预览很慢， 读者浏览网页格式也慢。 内容相近的章节可以作为一个“部分”。 为此， 在一个部分的第一个章节文件的章标题前面增加一行， 以 # (PART)开头， 以{-}结尾， 中间是部分的名称，书的最后可以有附录， 附录的章节将显示为A.1, B.1这样的格式。 5.3.3 书的编译 建议使用RStudio软件编辑内容， 管理和编译整本书。 在index.Rmd或者_bookdown.yml中设置site: bookdown::bookdown_site后， RStudio就能识别这个项目是一个bookdown项目， 这时RStudio会有一个Build窗格，其中有“Build book”快捷图标， 从下拉菜单中选择一个输出格式（包括gitbook、pdf_book、epub_book）， 就可以编译整本书。 对gitbook格式， 即HTML网页格式， 编译完成后会弹出一个预览窗口， 其中的“Open in Browser”按钮可以将内容在操作系统默认的网络浏览器中打开。 将书编译为PDF需要利用LaTeX编译器， 这需要单独安装LaTeX编译软件， LaTeX编译器对输入要求十分严格， 一丁点儿错误都会造成整本书的编译失败， 所以对于不熟悉LaTeX的用户， 不建议使用bookdown的pdf_book输出格式。 当前的R Markdown仅支持谢益辉的TinyTeX软件， 安装和管理参见22.12.1。 对于较短的书， 做了一定修改后都可以重新编译gitbook结果和pdf_book结果。 在书比较长了以后， 每次编译都花费很长时间， 所以可以仅编译gitbook格式的一章， 修改满意后再编译整本书。 仅编译一章也需要所有的.Rmd文件都是已经编译过一遍的， 新增的Rmd文件会使得编译单章出错， 每次新增了Rmd文件都应该重新编译整本书， 但是内容修改后不必要重新编译整本书， 可以仅编译单章。 编译完成后在结果目录（默认是_book）中找到相应的HTML文件打开查看， 再次编译后仅需在浏览器中重新载入文件。 建议使用Google chrome浏览器， 用MS IE或者Edge浏览器对gitbook的Javascrpt支持不够好， 使得目录的层级管理、自动滚动、单章编译后的目录更新不正常， 而chrome则没有问题。 编译单章也不能解决所有的问题， 有些问题还是需要编译整本书， 而章节很多时整本书编译又太慢。 为此， 可以在项目中增加一个临时的部分内容子目录， 如testing子目录， 在子目录中存放相同的设置文件index.Rmd、_bookdown.yml、_output.yml， 以及图形文件、文献数据库文件， 并将要检查的若干章节复制到testing子目录中， 在testing中新建一个bookdown项目， 然后编译其中的整本书。 这在调试部分章节的HTML和PDF输出时很有效。 解决问题后只要将修改过的章节复制回原始的书的目录中。 有时仅仅想验证某个长数学公式或者表格， 用上述的编译单章或者单独一个小规模测试项目的办法也不经济。 这时，单独开一个备用的普通RStudio项目， 不能是bookdown项目， 在其中的Rmd文件中验证数学公式和表格的编排， 这样最为方便。 有时需要根据编译输出目标采用不同的设置， 比如， 输出为html时可以使用HTML插件(widgets)， 而输出到PDF则不可以。 可以用 knitr::opts_knit$get(\"rmarkdown.pandoc.to\") 感知当前编译过程的目标， 对HTML类，输出为”html”， 对PDF，输出为”latex”。 5.3.4 交叉引用 在写作时，每个一级到三级标题都应该有自定义的标签， 格式是在标题行末尾空格后添加{#label}， 其中label是自己指定的标签， 使用英文、数字、减号， 不要使用中文， 而且整本书不要有重复的标签。 为避免不同章节使用了重复标签， 可以取label的前一部分为所在章节的文件名。 如果要引用某一章节， 有如下的做法： §\\@ref(label) label是某个标题对应的标签。 结果显示为如§3.1.1这样的章节号，并可点击， 点击时跳跃到相应的章节。 [链接文本](#label) 其中label是某个标题对应的标签。 结果产生一个链接，显示为链接文本，点击时跳到label对应的章节。 有时需要在数学公式内部、图形的说明中引用定理编号、公式编号等， 这需要预先定义单独的文字性引用， 然后再使用该文字引用。 定义文字引用如： (ref:mytextlabel) 见定理\\@ref(thm:orth) 可以在数学公式内部、图形说明的字符串内用(ref:mytextlabel)的格式调用上面定义的文字引用。 目前在数学公式内部使用有BUG。 5.3.5 数学公式和公式编号 通过R的knitr和rmarkdown扩展包以及pandoc软件， .Rmd格式文件已经支持数学公式， 见R Markdown说明。 在用$$符号在两端界定的公式后面， 可以用\\tag{标号}命令增加人为的公式编号，如 \\[ y = f(x) \\tag{*} \\] 结果显示为 要注意的是， 在$$界定的数学公式内用了aligned环境后， 仅能在\\end{aligned}之后加\\tag{标号}命令， 而不能写在aligned环境内。 这样， 多行的公式将不能为每行编号。 用\\tag命令人为编号比较简单易用， 但是在有大量公式需要编号时就很不方便， 只要增加了一个公式就需要人为地重新编号并修改相应的引用。 bookdown包支持对公式自动编号， 并可以按公式标签引用公式， 引用带有超链接。 bookdown的自动编号对LaTeX的equation环境、align环境都可以使用， 而且不需要在两端用$$界定。 在公式的末尾或者一行公式的\\换行符之前， 写\\((\\#eq:mylabel)\\)， 其中mylabel是自己给公式的文字标签， 文字标签可以使用英文字母、数字、减号、下划线。 如 \\[ \\begin{align} f(x) =&amp; \\sum_{k=0}^\\infty \\frac{1}{k!} x^k \\tag{5.1} \\\\ = e^x \\tag{5.2} \\end{align} \\] 将会对两行公式自动编号。 引用公式时， 用如\\(\\@ref(eq:mylabel)\\)，其中mylabel是公式的自定义标签， 编译后这样的引用会变成带有链接的圆括号内的编号。 公式编号在全书中都不要有冲突（不同的公式定义了相同的编号）。 一种办法是，自定义的公式标签的开头以章节文件名开头。 5.3.6 定理类编号 定理、引理、命题、例题等， 使用特殊的markdown代码格式， 以三个冒号开头， 以三个冒号结尾， 在开头的三个反单撇号后面空格后写{.theorem}表示定理。 在.theorem后面， 可以用空格分隔后写一个定理的自定义标签， 标签以#开头，由字母、数字、减号组成， #号作为标签的开头标志但不作为标签的一部分。 可以用name=“定理名称”指定一个显示的定理名。 设某个定理的自定义标签是#mythlabel， 则可以用如\\@ref(thm:mythlabel)引用此定理的编号， 编号是在每一章内从头编号的。 编号有自动生成的链接。 例如： Theorem 5.1 (弱收敛) \\(\\xi_n\\)依分布收敛到\\(\\xi\\)， 当且仅当对任意\\(\\mathbb R\\)上的一元实值连续函数\\(f(\\cdot)\\)都有 \\[ E f(\\xi_n) \\to E f(\\xi), \\ n \\to \\infty . \\] 当定理或例子内有列表时， 一定注意列表前后要空行， 否则会导致嵌套错误。 这种错误在编译HTML时无法发现， 但是会造成结果莫名其妙地出错。 bookdown提供了证明环境， 但是不太实用。 对例题， 将theorem替换成example， 在引用时将thm替换成exm。 如： Example 5.1 (依概率收敛不a.s.收敛反例) a.s.收敛推出依概率收敛， 但是反之不然。给出反例。 定理类的段落包括如下的种类： 表: 定理类段落 环境名 默认显示名 标签前缀 theorem Theorem thm lemma Lemma lem corollary Corollary cor proposition Proposition prp conjecture Conjecture cnj definition Definition def example Example exm exercise Exercise exr 其中的显示名可以在_bookdown.yml的language的label属性中修改. 5.3.7 文献引用 bookdown使用.bib格式的文献数据库， 关于.bib格式的文献数据库请参考LaTeX的有关说明。 在index.Rmd的YAML元数据部分或者_bookdown.yml中用bibliography可以设置使用的一个或者多个.bib格式的文献数据库文件。 设某篇文章的.bib索引键是Qin2007:comp， 用 @Qin2007:comp可以引用此文献， 用[@Qin2007:comp] 可以生成带有括号的引用， 引用都有超链接。 指定.bib文件时可以用相对路径， 如“../docs/mybib.bib”。 5.3.8 插图 bookdown图书的插图有两种， 一种是已经保存为图形文件的， 主要是png、jpg和pdf图片； 另一种是文中的R代码生成的图形。 已经有图形文件的， 可以用markdown格式原来的插图方法， 见markdown格式介绍。 但是，这样做不能给图形自动编号， 另外因为制作图书是有网页和PDF书两种主要输出格式的， 原有的插图方式在这两种输出格式上有细微的不一致。 所以，最好是统一使用Rmd的插图方法。 Rmd的插图方法就是写一段R代码段来插图， 如果是用程序作图，则代码中写作图的代码； 如果是已有的图形文件， 可以在一个单独的R代码段中用类似下面的命令插图： knitr::include_graphics(\"figs/myfig01.png\") 其中figs是存放图形文件的子目录名， myfig01.png是要插入的图形文件名。 这样， 如果同时还有myfig01.pdf的话， 则HTML输出使用png图片而PDF输出自动选用pdf文件。 另外， 插图的选项在代码段的选项中规定： 用代码段的fig.with和fig.height选项指定作图的宽和高（英寸）， 用out.width和out.height选项指定在输出中实际显示的宽和高， 实际显示的宽和高如果使用如”90%“这样的百分数单位则可以自动适应输出的大小。 为了使得插图可以自动编号并可以被引用， 为代码段指定标签并增加一个fig.cap=\"...\"选项指定图形标题。 代码段的标签变成浮动图形的标签，如myfiglabel， 则为了引用这个图只要用\\@ref(fig:myfiglabel)。 注意，在整本书中这些标签都不能重复， 否则编译LaTeX支持的PDF输出会失败。 有些插图会伴随很长的说明文字， 这可以用代码段的fig.cap=选项指定， 但是其中的Markdown特有的格式在转换LaTeX时不一定支持， 而且在代码段选项中写太长的文字说明也是的程序难以辨认。 所以， 可以使用文字引用的方式： 在单独的一段中， 用如下格式定义一段可引用的文字内容： (ref:mylabel) 这里用实际的文字内容代替，不允许换行，不能分段。 其中mylabel是自己定义的仅由英文大小写字母、数字和减号组成的引用标志符。在需要使用这段文字的位置，用(ref:mylabel)这种格式引用。 注意定义和引用都是用的(ref:mylabel)语法。 用R生成PDF格式的图形时， 需要指定中文作为family选项， 所以在每个源文件的开头应该加上如下的设置， 使得生成PDF图时中文能够正确显示： pdf.options(family=&quot;GB1&quot;) 5.3.9 Markdown表格 bookdown书的表格可以用markdown格式的表格， 最好仅使用管道表， 管道表对中文内容支持最好。 为了对这样的表格自动编号， 需要在表格的前面或者后面空开一行的位置， 写 Table: (\\#tab:mylabel) 表的说明 其中mylabel是自定义的表格标签。 在引用这个表时用如 \\@ref(tab:mylabel) 5.4 R blogdown（博客） 用R Markdown创建网站 5.4.1 R blogdown 简介 R blogdown 是什么? R语言的一个扩展包，用来制作网站的工具。 可以用非常简洁的方式快速搭建静态网页构成的网站。 虽然名字里有“博客”（blog）字样，但并不仅限于博客。非常适合搭建一个科研小组的展示窗口。 基于 markdown 扩展语法，可以在网页中方便地插入图表、脚注、数学公式、R 代码等元素。 非常容易将 bookdown 生成的论文转化成网页展示。 非常易于维护，迁移，备份。 blogdown 的背景平台是 R 语言，用户界面首选 RStudio ，产生的网站框架是 Hugo blogdown有两个主要的亮点： * 它制作的是静态网站，也就是说，网站只由静态文件组成，如HTML、CSS、JavaScript和图片等。你可以把网站托管在任何网络服务器上。该网站不需要像WordPress那样的服务器端脚本，如PHP或数据库。它只是一个静态文件的文件夹。 * 网站是由R的Markdown文档生成的（R是可选的，也就是说，你可以使用没有R代码块的普通Markdown文档）。这带来了大量的好处，特别是如果你的网站与数据分析或（R）编程有关。能够使用Markdown意味着简单，更重要的是可移植性（例如，你正在给自己一个机会，将你的博客文章转换成PDF，并在未来发布到期刊甚至书籍上）。R Markdown给你带来了动态文档的好处–你所有的结果，如表格、图形和内联值，都可以从R代码中动态地计算和呈现，因此你在网站上呈现的结果更有可能是可重复的。使用R Markdown的一个额外而重要的好处是，由于blogdown继承了bookdown的HTML输出格式，你将能够轻松地编写技术文档。例如，如果你愿意，可以写LaTeX数学公式、引文，甚至定理和证明。 5.4.2 R blogdown安装 5.4.2.1 blogdown 运行RStudio，在左上面板的代码窗口输入并运行以下代码： if(!require(devtools)) install.packages('devtools') devtools::install_github('rstudio/blogdown') 解释一下：由于 blogdown 目前只发布到了 GitHub 服务器上，尚未发布到CRAN，所以上面第一条代码先安装开发工具 devtools 包，第二行用这个包的install_github() 函数从 GitHub 安装。 5.4.2.2 Hugo 框架 在 RStudio 左上面板的代码窗口输入并运行以下代码： blogdown::install_hugo() 5.4.3 用 R blogdown 搭建个人博客 5.4.3.1 创建示例网站 首先，在你的电脑里新建一个文件夹，准备存放网站文件，假定是c:\\blogdown_default 创建网站只需在RStudio里运行两行代码： setwd('c:\\\\blogdown_default') blogdown::new_site() 在c:\\blogdown_default文件夹打开 public\\index.html，即网站的主页。 5.4.3.2 发布网站 上面搭建的网站，目前只存在于本地电脑里，下面我们发布到网上。 如果你像我一样，已经有了自己租用的服务器，上面有了WordPress博客，那最简单，在服务器的public_html\\文件夹下面创建一个新文件夹，例如叫做test，那么只需将刚刚在本地新建的博客或科研网站的 public文件夹里所有文件上传到服务器的test 文件夹即可。访问你的域名/test，就可以看到新网站了。 如果你没有自己的服务器，那么最简单的是在 netlify 免费注册个账号，然后按提示将你本地的 public\\ 文件夹拖进去，会自动布署，等几分钟，就可以访问了。你可以免费申请个子域名，也可以买个自己的域名绑定上去。 5.4.3.3 网站更新 将自动生成的网站更新成自己的，并添加新内容呢。 在新建的网站文件夹里有个content\\文件夹。这里就是更新网站内容的地方。你只需用记事本或RStudio，打开其中的.md或 .Rmd 文件，修改成自己的内容后保存，然后运行建站函数： blogdown::build_site() 这样，public\\就自动更新了，再发布到网上即可。 5.4.3.4 发布新帖子 方法一：将原有的.md或 .Rmd拷贝粘贴，改一下标题和内容即可； 方法二：在RSudio代码窗口点击 Addins- New Post， 按提示填写即可。 写完保存，运行建站函数，上传。完毕。 5.4.3.5 自动同步 如果嫌每次更新上传太麻烦，可以选择自动同步。 如果网站搭建在Netlify，那么只需做三件事： 下载并安装 GitHub 客户端，申请个免费账号，并创建一个项目，例如叫做myweb，将前面我们举例的c:\\blogdown_default 文件夹设为项目的文件夹，并同步到云端。 在你的Netlify设置里，设为自动跟你的GitHub里的myweb项目同步，同步内容是 public文件夹。 以后每次更新并运行完建站函数后，在GitHub客户端同步一下即可。 5.5 R的个人简历制作 我们在制作简历时，往往会在寻找模板、调整格式上下很多功夫，尤其是在更新简历时，往往需要进行大量的调整，甚至于从头再来，而R Markdown可以很好地解决这些问题，R Markdown有很多包都可以用来制作个人简历，例如datadrivencv，prettydoc，rticles，vitae等，下面以vitae为例，进行个人简历的制作。 5.5.1 安装vitae包 install.packages('vitae') 注：该功能需要LaTex包的支持，还需要下载一个tinytex包 install.packages(&#39;tinytex&#39;) tinytex::install_tinytex() 5.5.2 从模板创建简历 vitae包中有许多模板，我们可以在模板的基础上快速创建简历。具体方法是通过File -&gt; New File -&gt; R Markdown -&gt;From Template 可以看到有六个流行的CV模板可选，从中挑选你认为合适的模板即可。 5.5.3 编辑简历 创建好简历后，我们可以根据个人需求修改并填充简历的内容，基本语法在本章”R Markdown”小节中已经详细介绍，在此不赘述。 5.5.4 导出简历 编辑完成后，点击Knit导出我们想要的格式。当然，在编辑过程中，我们随时都可以通过Knit查看简历的效果，并根据所需进行调整和修改。 5.6 基于 R 语言的 Quarto 文档教程（前沿知识） 参考： https://quarto.org/docs/computations/r.html https://quarto.org/docs/get-started/hello/rstudio.html 5.6.1 Quarto文档概述 Quarto是RStudio的多语言、下一代R Markdown版本，包括数十个新特性和功能，同时能够不加修改地渲染大多数现有的Rmd文件。 像R Markdown一样，Quarto也使用Knitr执行R代码。 Quarto文档的拓展名为.qmd。 5.6.2 R Markdown文档和Quarto文档的区别 5.6.2.1 代码块选项 在Quarto代码块中，选项通常包含在代码块顶部的特殊注释中，而不是在块开头的行内。例如： #| echo: false #| fig-cap: &quot;Air Quality&quot; library(ggplot2) ggplot(airquality, aes(Temp, Ozone)) + geom_point() + geom_smooth(method = &quot;loess&quot;, se = FALSE) 在更结构化的编辑器中，无法简单地编辑数据块元数据，Quarto使用这种方法来更好地适应较长的选项，如figg -cap, figg -subcap和figg -alt，使得编辑数据块选项变得简单。 5.6.2.2 输出格式 R Markdown和Quarto的另一个区别与输出格式有关。Quarto包括更多内置输出格式（以及更多自定义每种格式的选项）。Quarto还具有网站、书籍和博客等特殊项目类型的原生功能（而不是依赖外部软件包）。 在Quarto中使用格式，是通过format键，而不是像在R Markdown中那样使用output键。以下是同等格式规格的比较： R Markdown title: &quot;My Document&quot; output: html_document: toc: true number_sections: true css: styles.css Quarto title: &quot;My Document&quot; format: html: toc: true number-sections: true css: styles.css 语法差异的一个来源是Quarto与Pandoc格式名称和选项更接近（因此使用-作为单词分隔符而不是_）。 5.6.3 创建Quarto文档 通过File &gt;- New File&gt;-Quarto Document创建新的Quarto文档 5.6.4 Quarto文档的内容 Quarto文档包含三种类型的内容：YAML标题、代码块和标记文本。 5.6.4.1 YAML标题 YAML标题的两端由三个破折号（---）分界： --- title: &quot;Hello, Quarto&quot; format: html editor: visual --- 渲染后，title\"Hello, Quarto\"将显示在渲染文档的顶部，字体大小大于文档的其余部分。另外两个YAML字段表示，默认情况下，输出应为htmlformat，文档应在visualeditor中打开。 YAML的基本语法在格式key: value中使用键值对。文档标题中常见的其他YAML字段包括author、subtitle、date等元数据，以及自定义选项，如theme、fontcolor、fig-width等。 5.6.4.2 代码块 用{r}标识的R代码块，带有块状选项，以YAML样式标识，在行开头由#|标识。 #| label: load-packages #| include: false library(tidyverse) library(palmerpenguins) 在这种情况下，代码块的label是load-packages，我们将include设置为false，以表明我们不希望该块本身或其任何输出结果出现在渲染的文档中。 5.6.4.3 标记文本 Quarto文档对文本使用markdown语法，如果使用可视化编辑器，您无需学习太多的标记语法来编写文档，因为您可以使用菜单和快捷方式添加标题、粗体文本、插入表格等。如果使用源编辑器，您可以使用##、**bold**等标记表达式来实现。 5.6.5 渲染和预览 使用Render按钮（快捷键⇧⌘K）在编辑文档时预览文档，如果您更喜欢在每次保存时自动渲染，您可以在编辑器工具栏上勾选”Render on Save”选项，然后预览视图将与编辑器一起显示，每当您重新渲染文档时，预览都会更新。并排预览适用于HTML和PDF输出。 文档也可以通过quarto包从R控制台渲染: install.packages(&quot;quarto&quot;) quarto::quarto_render(&quot;hello.qmd&quot;) 渲染时，Quarto会生成一个新文件，其中包含来自.qmd文件的选定文本、代码和结果。新文件可以是HTML、PDF、MS Word文档、演示文稿、网站、书籍、交互式文档或其他格式。 5.6.6 工作方式 当您渲染Quarto文档时，首先通过knitr执行所有代码块，并创建一个新的markdown（.md）文档，其中包括代码及其输出。然后，生成的标记文件由pandoc处理，pandoc创建完成的格式。“渲染”按钮封装了这些操作，并按照正确的顺序执行。 "],["体育运动科学领域的专业r包.html", "第 6 章 体育运动科学领域的专业R包 6.1 个人运动项目R包 6.2 团体运动项目R包", " 第 6 章 体育运动科学领域的专业R包 6.1 个人运动项目R包 6.1.1 游泳 SwimmeR可以读取各种格式的游泳成绩，并输出整洁的数据集。它还包括短道码（SCY）、短道米（SCM）和长道米（LCM）之间的时间转换功能。 6.1.2 田径 combinedevents包含用于计算田径综合项目比赛的得分和分数的函数(基于国际田联的评分表)。 JumpeR包含导入和分析田径数据的功能。 6.1.3 赛车F1 f1dataR通过fastf1python库包装Ergast API Formula 1数据和F1官方数据的功能集合。 6.1.4 电子竞技 CSGo从Steam API中收集反恐精英全球攻势的数据。 rbedrock支持Minecraft（Bedrock版）的数据分析和管理。 ROpenDota、opendotaR和RDota2从OpenDota和Steam API中提取Dota2数据。 6.1.5 国际象棋 chess是一个围绕Python-chess的R的意见包装器。它读取和写入PGN文件和棋盘的SVG。 stockfish实现了UCI开放通信协议，并与stockfish一起使用，stockfish是一个流行的、开源的、强大的用C++编写的国际象棋引擎。 像国际象棋一样，bigchess可以读写PGN文件。和stockfish一样，bigchess为UCI国际象棋引擎提供了一个API。bigchess也能够一次读取多个比赛文件，而不需要复制到RAM中。 rchess提供了国际象棋验证、棋子移动、检查检测和绘制棋盘的功能。 chessR (archived)允许用户从在线国际象棋应用程序中获取棋谱数据，包括chess.com和Lichess。 6.1.6 科学化运动训练监控 6.2 团体运动项目R包 6.2.1 篮球 BAwiR是一个分析篮球数据的工具集合，重点是数据获取和可视化。 AdvancedBasketballStats提供了计算和分析球员、球队、阵容（五人组）和比赛的篮球统计数据的功能。 uncmbb包含自1949-50赛季以来北卡罗来纳大学（教堂山分校）男子篮球比赛结果的数据。 BasketballAnalyzeR基于《Basketball Data Science With Applications in R》一书。包含一些用于分析和可视化的篮球数据和函数。 NBAloveR是一个R接口，用于从Basketball Reference API访问篮球数据。这个包还包含帮助用户分析篮球数据的函数。 wehoop提供了从ESPN API访问女子大学篮球和WNBA数据的函数。 hoopR包括从不同来源访问大学男子篮球和NBA数据的函数，包括ESPN、NBA Stats API和Ken Pomeroy的大学篮球评级。 toRvik (archived)包括从Barttorvik获取大学男子篮球高级指标、球员和比赛统计等数据的功能。 6.2.2 足球 worldfootballR提供来自许多热门网站的干净整洁的足球数据，包括FBref、Transfermarkt的转会和估值数据以及Understat和fotmob的射击位置数据。 欧洲足球数据可以通过engsoccerdata包获得，可追溯到1871年的英国和其他欧洲足球联赛的比赛结果。 socceR提供评估足球预测和模拟足球比赛和锦标赛结果的功能。 StatsBombR用于直接从API中提取StatsBomb的数据。目前，只适用于Windows电脑。 ggsoccer提供了在ggplot2中可视化足球比赛数据的功能。 footballpenaltiesBL包含数据和绘图功能，用于分析1963-64赛季至2016-17赛季德甲的点球。 footBayes包含通过哈密尔顿蒙特卡洛（Hamilton Monte Carlo）和使用Stan的最大似然估计方法拟合广为人知的足球模型（双泊松分布、双变量泊松分布、Skellam分布、t检验）的功能。该包还提供了用于可视化球队实力和预测比赛结果的工具。 itscalledsoccer (archived)通过美国足球分析应用程序API实现对美国足球（MLS、NWSL和USL）数据的访问。 FPLdata包含在幻想超级联赛上检索玩家属性的功能。 EUfootball提供2010-11赛季至2019-20赛季英国、法国、德国、意大利、西班牙、荷兰和土耳其顶级联赛的欧洲足球比赛结果。 CodaBonito用于足球相关的可视化和分析 6.2.3 橄榄球 nflverse是用于获取和分析NFL数据的软件包集合，包括nflfastR、nflseedR、nfl4th、nflreadr和nflplotR。 nflfastR包含一些函数，可以高效地获取1999年至今的NFL逐场比赛数据。它类似于nflscrapR，但速度要快得多。nflfastR所需的所有模型都托管在fastr模型中。 nflreadr可以从nflverse项目的GitHub存储库中高效地下载数据，包括预先计算的nflfastR数据帧。 nfl4th由计算NFL？？？？的函数组成。？？？？的数据是从NFL和ESPN收集的。 nflseedR包含根据复杂的NFL打破平局规则对NFL球队进行排名的功能。它包括分区排名、季后赛种子排名和选秀顺序。 nflplotR包含使ggplot2中的NFL数据可视化更容易的功能。 nflscrapR包允许数据驱动的体育爱好者使用NFL JSON API数据来进行比赛、赛季和球员层面的详细分析。这个包中的函数有助于为R用户解析和清理NFL.com的数据。这个包的建立是为了加强专门针对橄榄球的高级体育分析研究，希望能开发出对专业NFL球队和公众都有潜在帮助的指标和见解。 NFLSimulatoR由模拟比赛和驱动器的工具组成，并进一步评估NFL的比赛战术策略。 fflr提供从ESPN幻想足球API访问ESPN幻想足球原始数据并格式化原始数据的功能。 ffscrapr通过一致的界面和内置身份验证、速率限制和缓存来帮助访问各种幻想足球API，包括MFL、Sleeper、ESPN和Fleaflicker。 ffsimulator允许用户使用自举重采样（bootstrap-resampling）模拟幻想足球赛季。模拟基于历史排名和nflfastR包的数据。此外，还提供了计算最佳阵容和汇总结果的功能。 gsisdecoder包含解码NFL Player ID的功能，以便与nflfastR包一起使用。 cfbfastR提供从 collegefootballdata.com网站获取大学橄榄球比赛逐场数据的功能。 cfbscrapR用于处理大学足球数据的R包。它是cfbscrapR团队提供的围绕https://collegefootballdata.com/的R API封装器。它为用户提供了访问大量端点的能力，并通过额外的信息（增加的预期分数/增加的获胜概率）来补充这些数据。 6.2.4 澳式足球 fitzRoy是一个用于获取和处理澳大利亚足球联赛（AFL）数据的软件包。fitzRoy提供开源访问，如AFL Tables、Footy Wire和The Squiggle。 6.2.5 棒球 历史棒球数据可以通过Lahman包获得，它包含了MLB自1871年以来的各赛季数据。 retrosheet便于从Retrosheet.org下载比赛记录、球队ID、花名册和比赛场上的行为事件以及其他文件，并将结果作为数据帧返回。可以采用本地缓存来提高效率。请注意，返回的逐场比赛数据直接来自比赛文件，没有经过解析（即Chadwick没有被捆绑）。 pitchRx通过MLB高级媒体API提供对投球数据的访问。该软件包在Marchi, M., Albert, J., and Baumer, B. S. (2018). Analyzing baseball data with R (doi:10.1201/9781351107099).中占据了突出地位。用R分析棒球数据（doi:10.1201/9781351107099）。该包的完整描述见Sievert, C. (2014). Taming PITCHf/x Data with XML2R and pitchRx (doi:10.32614/RJ-2014-001)。 mlbstats为许多棒球数据的矢量计算提供函数，包括传统的和计量的。 baseballDBR利用dplyr的后端数据库功能来建立本地数据库，镜像Lahman中包含的数据。像mlbstats一样，它也包括计算棒球数据的函数，但是是在数据框架而不是向量上。 baseballr包含从各种来源提取和分析棒球数据的函数，如Baseball Reference, FanGraphs, 和Baseball Savant。 collegeballR从stats.ncaa.org收集大多数大学体育项目的NCAA统计数据。 GeomMLBStadiums在ggplot2框架中绘制MLB场馆。 openWAR这个包有两个主要目的。1）它促进了openWAR的计算，这是一个完全开源的Wins Above Replacement（WAR）的实现，可以作为证券计量学界的参考实现；2）它从MLBAM GameDay网络应用中下载原始的XML文件，并将其处理成表格格式的逐场比赛数据。这种逐场比赛信息在精神上与retrosheet提供的逐场比赛数据相似，尽管在语法上不一样。那些对我们在计算openWAR时所作的建模选择感兴趣的人，应该查阅我们在JQAS或arXiv上关于这个问题的论文。openWAR的这个实现包括为每个球员构建WAR的区间估计的功能，以及将openWAR的点估计与Baseball- Reference.com的rWAR进行比较。 6.2.6 排球 volleystat包含2013-14赛季至2018-19赛季德甲联赛的比赛统计数据，数据来源于联赛网站。 6.2.7 冰球 hockey-all包含所有冰球运动所需的数据和函数 elite允许用户以[相当]整洁的方式轻松获取EliteProspects的数据 nhlapi检索和处理开放的“NHL”API公开的数据。这包括有关球员、球队、比赛、锦标赛、选秀、排名、时间表和其他端点的信息。还提供了一个较低级别的界面，可以直接通过URL访问数据。 nhlscrape将比赛事件添加到数据库文件中，用于冰球比赛的统计分析。这意味着我们只想为每个要添加的比赛调用一次“NHL”API。一旦添加了比赛，我们将非常快速地检索数据，因为数据存储在本地。我们使用位于https://statsapi.web.nhl.com/api/v1/teams的API以及来自https://www.nhl.com/scores/的补充数据。其他端点可以在https://gitlab.com/dword4/nhlapi上找到。 fastRhockey用于获取和加载来自PHFhttps://www.premierhockeyfederation.com/的逐场数据和统计数据的实用工具。此外，允许访问NHL的统计APIhttps://www.nhl.com/。 FHSTR提供来自NBC API的2022年北京奥运会的数据，该包将会持续更新数据和功能 6.2.8 板球 yorkr提供基于Cricsheet数据的板球运动员和球队的统计分析功能。 cricketr是一个工具集，用于分析基于ESPN Cricinfo Statsguru数据的球员和球队的板球表现。 cricketdata包括从ESPN Cricinfo和Crickesheet两个主要来源获得国际板球数据的功能。 howzatR由计算各种板球统计数据的函数组成。 6.2.9 垒球 runexp提供了估算垒球比赛得分的方法。特别的是，runexp围绕着使用离散马尔科夫链的理论期望值和使用多指标随机模拟的经验分布。 6.2.10 GPS追踪 trackeR和trackeRapp提供了在R中分析来自GPS跟踪设备的跑步、骑行和游泳数据的工具。这两个包允许用户整理和探索来自锻炼和比赛的数据。 rStrava包含从Strava API访问Strava活动数据的功能。 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
